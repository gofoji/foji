// Code generated by foji, template: {{ templateFile }}; DO NOT EDIT.
{{- $pkgName := "pg" }}
{{- $table := .Table.Name}}
{{- $schema := .Table.Schema.Name}}
{{- $goName := case $table }}
{{- $hasSoftDeletes := .Table.Columns.Names.Contains "deleted_at"}}
{{- $mutableCols := (.Table.Columns.Filter .Table.PrimaryKeys.Paths).ByOrdinal.Names }}
{{- $mutableFields := (cases $mutableCols).Sprintf "row.%s"}}
{{- $scanFields := (cases .Table.Columns.ByOrdinal.Names).Sprintf "&row.%s"}}
{{- $selectFields := csv .Table.Columns.ByOrdinal.Names}}
{{- $PKs := cases .Table.PrimaryKeys.ByOrdinal.Names }}
{{- $PKFields := csv ($PKs.Sprintf "row.%s")}}
{{- $PKScanFields := csv ($PKs.Sprintf "&row.%s")}}

package {{ $pkgName }}

import (
	"context"
	"fmt"

	"github.com/jackc/pgx/v5"

	"{{.Params.Package}}"
{{- range .Imports }}
	"{{ . }}"
{{- end }}
)

const querySelect{{$goName}} = `SELECT
	{{ $selectFields }}
FROM {{$schema}}.{{$table}} `

func scan{{$goName}}(rr pgx.Rows) ([]*{{$.PackageName}}.{{$goName}}, error) {
	var result []*{{$.PackageName}}.{{$goName}}

	for rr.Next() {
		row := {{$.PackageName}}.{{$goName}}{}
		err := rr.Scan({{ csv $scanFields }})
		if err != nil {
			return nil, fmt.Errorf("scan{{$goName}}:%w", err)
		}
		result = append(result, &row)
	}

	return result, nil
}

func scanOne{{$goName}}(rr pgx.Row) (*{{$.PackageName}}.{{$goName}}, error) {
	row := {{$.PackageName}}.{{$goName}}{}

	err := rr.Scan({{ csv $scanFields }})
	if err != nil {
		return nil, fmt.Errorf("{{$goName}}:%w", err)
	}

	return &row, nil
}

// All retrieves all rows from '{{$table}}' as a slice of {{$goName}}.
func (r Repo) All{{$goName}}(ctx context.Context) ([]*{{$.PackageName}}.{{$goName}}, error) {
	query :=  querySelect{{$goName }}
{{- if $hasSoftDeletes -}}
	+ `WHERE deleted_at is NULL `
{{- end}}

	q, err := r.db.Query(ctx,query)
	if err != nil {
		return nil, fmt.Errorf("{{$goName}}:%w", err)
	}

	return scan{{$goName}}(q)
}

{{- /* Takes the number of values to produce and produces a list of postgres
placeholders of the form $1, $2, etc */}}
{{- define "values" -}}
	{{$nums := numbers 1 . -}}
	{{$indices := $nums.Sprintf "$%s" -}}
	{{csv $indices -}}
{{end}}

// Insert inserts the row into the database.
func (r Repo) Insert{{$goName}}(ctx context.Context, row *{{$.PackageName}}.{{$goName}}) error {
const query = `INSERT INTO {{$schema}}.{{$table}}
{{- if gt (len $mutableCols) 0}}
	({{ csv $mutableCols }})
	VALUES
	({{template "values" (len $mutableCols) }})
{{- else}}
	DEFAULT VALUES
{{- end}}
	RETURNING
		{{csv .Table.PrimaryKeys.Names.Sort }}`
	q := r.db.QueryRow(ctx, query,{{- csv $mutableFields }})
	return q.Scan({{$PKScanFields}})
}
{{if gt (len $mutableCols) 0}}
// Update the Row in the database.
func (r Repo) Update{{$goName}}(ctx context.Context, row *{{$.PackageName}}.{{$goName}}) error {
	query := `UPDATE {{$schema}}.{{$table}}
	SET
		({{csv $mutableCols }}) =
		({{ template "values" (len $mutableCols) }})
	WHERE
	{{$last := sum (len .Table.PrimaryKeys) (len $mutableCols)}}
	{{- $first := inc (len $mutableCols)}}
	{{- range $x, $name := .Table.PrimaryKeys.Names.Sort -}}
		{{$name}} = ${{sum $first $x}}{{if lt (sum $x $first) $last}} AND {{end}}
	{{- end}}`

	_, err := r.db.Exec(ctx, query, {{csv $mutableFields }}, {{$PKFields}})
	if err != nil {
		return fmt.Errorf("Update{{$goName}}:%w", err)
	}

	return nil
}
{{end}}

{{- if .Table.HasPrimaryKey }}
{{- if $hasSoftDeletes}}
// Delete{{$goName}} soft deletes the row from the database. Returns the number of items soft deleted.
{{- else}}
// Delete{{$goName}} deletes the Row from the database. Returns the number of items deleted.
{{- end}}
func (r Repo) Delete{{$goName}}( ctx context.Context, {{ $.Parameterize .Table.PrimaryKeys "%s %s" $pkgName }}) (int64, error) {
	{{- if $hasSoftDeletes}}
	const query = `UPDATE {{$schema}}.{{$table}}
		SET deleted_at = now()
		WHERE
		{{ range $x, $name := .Table.PrimaryKeys.Names.Sort -}}
			{{$name}} = ${{inc $x}}{{if lt $x (sum (len $.Table.PrimaryKeys) -1)}} AND {{end}}
		{{- end}} AND deleted_at is NULL
		`
	{{- else }}
	const query = `DELETE FROM {{$schema}}.{{$table}} WHERE
		{{ range $x, $name := .Table.PrimaryKeys.Names.Sort -}}
			{{$name}} = ${{inc $x}}{{if lt $x (sum (len $.Table.PrimaryKeys) -1)}} AND {{end}}
		{{- end}}`{{- end}}

	res, err := r.db.Exec(ctx, query,
	{{- csv .Table.PrimaryKeys.Names.Sort.Camel  -}}
	)
	if err != nil {
		return 0, fmt.Errorf("{{$goName}}:%w", err)
	}

	return res.RowsAffected(), nil
}
{{- if $hasSoftDeletes}}
// DeletePermanent{{$goName}} deletes the Row from the database. This bypasses the soft delete mechanism.
// Returns the number of items deleted.
func (r Repo) DeletePermanent{{$goName}}( ctx context.Context, {{ $.Parameterize .Table.PrimaryKeys "%s %s" $pkgName }}) (int64, error) {
	const query = `DELETE FROM {{$schema}}.{{$table}} WHERE
		{{ range $x, $name := .Table.PrimaryKeys.Names.Sort -}}
			{{$name}} = ${{inc $x}}{{if lt $x (sum (len $.Table.PrimaryKeys) -1)}} AND {{end}}
		{{- end}}`

	res, err := r.db.Exec(ctx, query,
	{{- csv .Table.PrimaryKeys.Names.Sort.Camel  -}}
	)
	if err != nil {
		return 0, fmt.Errorf("{{$goName}}:%w", err)
	}

	return res.RowsAffected(), nil
}
{{end}}
{{end}}

{{ range .Table.Indexes -}}
	{{- $FuncName := print $goName "By" ((cases .Columns.Names).Join "") -}}
	{{- if $.Table.PrimaryKeys.Names.ContainsAll .Columns.Names -}}
		{{- $FuncName = print "Get" $goName -}}
	{{- end -}}
// {{$FuncName}} retrieves a row from '{{$.Table.Schema.Name}}.{{$.Table.Name}}'.
//
// Generated from index '{{.Name}}'.
func (r Repo) {{ $FuncName }}(ctx context.Context, {{ $.Parameterize .Columns "%s %s" $pkgName }}) ({{ if not .IsUnique }}[]{{ end }}*{{$.PackageName}}.{{$goName}}, error) {
	query := querySelect{{$goName}} + ` WHERE {{csv .Columns.Names.Sort }} = {{template "values" (len .Columns)}}
{{- if $hasSoftDeletes }} AND deleted_at is NULL{{ end}}`

{{- if .IsUnique }}
	q := r.db.QueryRow(ctx, query, {{ csv (.Columns.Names.Sort.Camel) }})
{{- else }}
	q, err := r.db.Query(ctx, query, {{ csv (.Columns.Names.Sort.Camel) }})
	if err != nil {
		return nil, fmt.Errorf("{{$goName}}.{{ $FuncName }}:%w", err)
	}
{{- end }}

{{- if .IsUnique }}
	return scanOne{{$goName}}(q)
{{- else }}
	return scan{{$goName}}(q)
{{- end }}
}

{{ end }}