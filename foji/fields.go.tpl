// Code generated by foji {{ version }}, template: {{ templateFile }}; DO NOT EDIT.

package {{ .PackageName }}

import (
	"bytes"
	"database/sql"
	"database/sql/driver"
	"encoding/json"
	"errors"
	"fmt"
	"strconv"
	"strings"
	"time"

	"github.com/google/uuid"
)

var errByteArrayCast = errors.New("type assertion .([]byte) failed")
var errJsonbCast = errors.New("reading from DB into Jsonb, failed to convert to map[string]any")

// Bytea is a wrapper around byte arrays specifically for bytea column types in postgres.
type Bytea []byte

// Jsonb is a wrapper for map[string]any for storing json into postgres
type Jsonb map[string]any

// Value marshals the json into the database
func (j Jsonb) Value() (driver.Value, error) {
	return json.Marshal(j)
}

// Scan Unmarshalls the bytes[] back into a Jsonb object
func (j *Jsonb) Scan(src any) error {
	source, ok := src.([]byte)
	if !ok {
		return errByteArrayCast
	}

	var i map[string]any
	err := json.Unmarshal(source, &i)
	if err != nil {
		return err
	}
	*j = i

	return nil
}

type OrderByClause interface {
	String() string
}

// OrderByDesc returns a sort order descending by the given field.
func OrderByDesc(field string) OrderBy {
	return OrderBy{
		Field: field,
		Order: OrderDesc,
	}
}

// OrderByAsc returns a sort order ascending by the given field.
func OrderByAsc(field string) OrderBy {
	return OrderBy{
		Field: field,
		Order: OrderAsc,
	}
}

// OrderBy indicates how rows should be sorted.
type OrderBy struct {
	Field string
	Order SortOrder
}

func (o OrderBy) String() string {
	if o.Order == OrderNone {
		return ""
	}
	return " ORDER BY " + o.Field + " " + o.Order.String() + " "
}

// SortOrder defines how to order rows returned.
type SortOrder int

// Defined sort orders for not sorted, descending and ascending.
const (
	OrderNone SortOrder = iota
	OrderDesc
	OrderAsc
)

// String returns the sql string representation of this sort order.
func (s SortOrder) String() string {
	switch s {
	case OrderDesc:
		return "DESC"
	case OrderAsc:
		return "ASC"
	}
	return ""
}

// WhereClause has a String function should return a properly formatted where
// clause (not including the WHERE) for positional arguments starting at idx.
type WhereClause interface {
	String(idx *int) string
	Values() []any
}

// Comparison is used by WhereClauses to create valid sql.
type Comparison string

// Comparison types.
const (
	CompEqual   Comparison = " = "
	CompGreater Comparison = " > "
	CompLess    Comparison = " < "
	CompGTE     Comparison = " >= "
	CompLTE     Comparison = " <= "
	CompNE      Comparison = " <> "
)

type Where struct {
	Field string
	Comp  Comparison
	Value any
}

func (w Where) String(idx *int) string {
	ret := w.Field + string(w.Comp) + "$" + strconv.Itoa(*idx)
	(*idx)++
	return ret
}

func (w Where) Values() []any {
	return []any{w.Value}
}

// NullClause is a clause that checks for a column being null or not.
type NullClause struct {
	Field string
	Null  bool
}

func (n NullClause) String(_ *int) string {
	if n.Null {
		return n.Field + " IS NULL "
	}
	return n.Field + " IS NOT NULL "
}

func (n NullClause) Values() []any {
	return []any{}
}

// AndClause returns a WhereClause that serializes to the AND
// of all the given where clauses.
func AndClause(wheres ...WhereClause) WhereClause {
	return andClause(wheres)
}

type andClause []WhereClause

func (a andClause) String(idx *int) string {
	wheres := make([]string, len(a))
	for x := 0; x < len(a); x++ {
		wheres[x] = a[x].String(idx)
	}
	return strings.Join(wheres, " AND ")
}

func (a andClause) Values() []any {
	vals := make([]any, 0, len(a))
	for x := 0; x < len(a); x++ {
		vals = append(vals, a[x].Values()...)
	}
	return vals
}

// OrClause returns a WhereClause that serializes to the OR
// of all the given where clauses.
func OrClause(wheres ...WhereClause) WhereClause {
	return orClause(wheres)
}

type orClause []WhereClause

func (o orClause) String(idx *int) string {
	wheres := make([]string, len(o))
	for x := 0; x < len(wheres); x++ {
		wheres[x] = o[x].String(idx)
	}
	return strings.Join(wheres, " OR ")
}

func (o orClause) Values() []any {
	vals := make([]any, len(o))
	for x := 0; x < len(o); x++ {
		vals = append(vals, o[x].Values()...)
	}
	return vals
}

// InClause takes a slice of values that it matches against.
type InClause struct {
	Field  string
	Vals []any
}

func (in InClause) String(idx *int) string {
	ret := in.Field + " in ("
	for x := range in.Vals {
		if x != 0 {
			ret += ", "
		}
		ret += "$" + strconv.Itoa(*idx)
		(*idx)++
	}
	ret += ")"
	return ret
}

func (in InClause) Values() []any {
	return in.Vals
}

type PrefixMatch struct {
	Field string
	Value any
}

func (w PrefixMatch) String(idx *int) string {
	ret := "$" + strconv.Itoa(*idx) + " ILIKE " + w.Field
	(*idx)++
	return ret
}

func (w PrefixMatch) Values() []any {
	return []any{w.Value}
}


type PInt32 *int32
type PString *string

func NewPInt32(i int32) PInt32{
  return &i
}

// Time is a nullable time.Time. It supports SQL and JSON serialization.
// It will marshal to null if null.
type Time struct {
	sql.NullTime
}

// Value implements the driver Valuer interface.
func (t Time) Value() (driver.Value, error) {
	if !t.Valid {
		return nil, nil
	}
	return t.Time, nil
}

// TimeFrom creates a new Time that will always be valid.
func TimeFrom(t time.Time) Time {
	return Time{
		NullTime: sql.NullTime{
			Time:  t,
			Valid: true,
		},
	}
}

// MarshalJSON implements json.Marshaler.
// It will encode null if this time is null.
func (t Time) MarshalJSON() ([]byte, error) {
	if !t.Valid {
		return []byte("null"), nil
	}
	return t.Time.MarshalJSON()
}

// nullBytes is a JSON null literal
var nullBytes = []byte("null")

// UnmarshalJSON implements json.Unmarshaler.
// It supports string and null input.
func (t *Time) UnmarshalJSON(data []byte) error {
	if bytes.Equal(data, nullBytes) {
		t.Valid = false
		return nil
	}

	if err := json.Unmarshal(data, &t.Time); err != nil {
		return fmt.Errorf("null: couldn't unmarshal JSON: %w", err)
	}

	t.Valid = true
	return nil
}

// MarshalText implements encoding.TextMarshaler.
// It returns an empty string if invalid, otherwise time.Time's MarshalText.
func (t Time) MarshalText() ([]byte, error) {
	if !t.Valid {
		return []byte{}, nil
	}
	return t.Time.MarshalText()
}

// UnmarshalText implements encoding.TextUnmarshaler.
// It has backwards compatibility with v3 in that the string "null" is considered equivalent to an empty string
// and unmarshaling will succeed. This may be removed in a future version.
func (t *Time) UnmarshalText(text []byte) error {
	str := string(text)
	// allowing "null" is for backwards compatibility with v3
	if str == "" || str == "null" {
		t.Valid = false
		return nil
	}
	if err := t.Time.UnmarshalText(text); err != nil {
		return fmt.Errorf("null: couldn't unmarshal text: %w", err)
	}
	t.Valid = true
	return nil
}

// SetValid changes this Time's value and sets it to be non-null.
func (t *Time) SetValid(v time.Time) {
	t.Time = v
	t.Valid = true
}

// Ptr returns a pointer to this Time's value, or a nil pointer if this Time is null.
func (t Time) Ptr() *time.Time {
	if !t.Valid {
		return nil
	}
	return &t.Time
}

// IsZero returns true for invalid Times, hopefully for future omitempty support.
// A non-null Time with a zero value will not be considered zero.
func (t Time) IsZero() bool {
  return !t.Valid
}

// Equal returns true if both Time objects encode the same time or are both null.
// Two times can be equal even if they are in different locations.
// For example, 6:00 +0200 CEST and 4:00 UTC are Equal.
func (t Time) Equal(other Time) bool {
  return t.Valid == other.Valid && (!t.Valid || t.Time.Equal(other.Time))
}

// ExactEqual returns true if both Time objects are equal or both null.
// ExactEqual returns false for times that are in different locations or
// have a different monotonic clock reading.
func (t Time) ExactEqual(other Time) bool {
  return t.Valid == other.Valid && (!t.Valid || t.Time == other.Time)
}

{{ range (toSlice "PString" "PInt32" "Jsonb" "int" "int32" "string"  "int64" "float64" "bool"  "time.Time" "Time" "uint32" "uuid.UUID") }}
{{ $fieldName := title (replace "." "" .) }}// {{$fieldName}}Field is a component that returns a WhereClause that contains a
// comparison based on its field and a strongly typed value.
type {{$fieldName}}Field string

// OrderBy returns a OrderByClause for this field.
func (f {{$fieldName}}Field) OrderBy(v SortOrder) OrderByClause {
	return OrderBy{
		Field: string(f),
		Order:  v,
	}
}

// OrderByAsc returns a OrderByClause for this field.
func (f {{$fieldName}}Field) OrderByAsc() OrderByClause {
	return OrderBy{
		Field: string(f),
		Order:  OrderAsc,
	}
}

// OrderByDesc returns a OrderByClause for this field.
func (f {{$fieldName}}Field) OrderByDesc() OrderByClause {
	return OrderBy{
		Field: string(f),
		Order:  OrderDesc,
	}
}

// Equals returns a WhereClause for this field.
func (f {{$fieldName}}Field) Equals(v {{.}}) Where {
	return Where{
		Field: string(f),
		Comp:  CompEqual,
		Value: v,
	}
}

// GreaterThan returns a WhereClause for this field.
func (f {{$fieldName}}Field) GreaterThan(v {{.}}) Where {
	return Where{
		Field: string(f),
		Comp:  CompGreater,
		Value: v,
	}
}

// LessThan returns a WhereClause for this field.
func (f {{$fieldName}}Field) LessThan(v {{.}}) Where {
	return Where{
		Field: string(f),
		Comp:  CompLess,
		Value: v,
	}
}

// GreaterOrEqual returns a WhereClause for this field.
func (f {{$fieldName}}Field) GreaterOrEqual(v {{.}}) Where {
	return Where{
		Field: string(f),
		Comp:  CompGTE,
		Value: v,
	}
}

// LessOrEqual returns a WhereClause for this field.
func (f {{$fieldName}}Field) LessOrEqual(v {{.}}) Where {
	return Where{
		Field: string(f),
		Comp:  CompLTE,
		Value: v,
	}
}

// NotEqual returns a WhereClause for this field.
func (f {{$fieldName}}Field) NotEqual(v {{.}}) Where {
	return Where{
		Field: string(f),
		Comp:  CompNE,
		Value: v,
	}
}

// In returns a WhereClause for this field.
func (f {{$fieldName}}Field) In(vals ...{{.}}) InClause {
	values := make([]any, len(vals))
	for x := range vals {
		values[x] = vals[x]
	}
	return InClause{
		Field: string(f),
		Vals: values,
	}
}

{{end}}

{{ range (toSlice  "PString" "PInt32" "Jsonb" "Time" ) }}
{{ $fieldName := title (replace "." "" .) }}
// IsNull returns a WhereClause that matches when this field is NULL.
func (f {{$fieldName}}Field) IsNull() NullClause {
	return NullClause{
		Field: string(f),
		Null: true,
	}
}

// IsNotNull returns a WhereClause that matches when this field is not NULL.
func (f {{$fieldName}}Field) IsNotNull() NullClause {
	return NullClause{
		Field: string(f),
		Null: false,
	}
}

{{end}}

// InterfaceField is a component that returns a WhereClause that contains a
// comparison based on its field and a strongly typed value.  Currently any is not supported.
type InterfaceField string

