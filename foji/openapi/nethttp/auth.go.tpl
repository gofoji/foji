{{ .NotNeededIf (empty .API.Components.SecuritySchemes) "no security schemes" -}}
{{ .ErrorIf (empty $.Params.Auth) "params.Auth" -}}
// Code generated by foji {{ version }}, template: {{ templateFile }}; DO NOT EDIT.
{{ $packageName := .PackageName }}
package {{$packageName}}

import (
	"net/http"

	"github.com/bir/iken/httputil"
)

// HttpAuthFunc is the signature of a function used to authenticate an http request.
// Given a request, it returns the authenticated user.  If unable to authenticate the
// request it returns an error.
type HttpAuthFunc = func(r *http.Request)(*{{ $.CheckPackage $.Params.Auth $packageName }}, error)

// Authenticator takes a key (for example a bearer token) and returns the authenticated user.
type Authenticator = func(key string) (*{{ $.CheckPackage $.Params.Auth $packageName }}, error)

{{- if .HasBasicAuth }}

// BasicAuthenticator takes a user/pass pair and returns the authenticated user.
type BasicAuthenticator = func(user,pass string) (*{{ $.CheckPackage $.Params.Auth $packageName }}, error)
{{- end}}

{{- if .HasAuthorization }}

// Authorizer is given an authenticated User and a list of scopes to validate.
type Authorizer = func(user *{{ $.CheckPackage $.Params.Auth $packageName }}, scopes ...string ) (error)
{{- end}}

{{- if or .HasBasicAuth .HasBearerAuth }}
var (
{{- if .HasBasicAuth }}
    basicAuthPrefix = []byte("Basic ")
{{- end}}
{{- if .HasBearerAuth }}
    bearerAuthPrefix = []byte("Bearer ")
{{- end}}
)
{{- end}}

{{- range $security, $value := .File.API.Components.SecuritySchemes }}

// {{ pascal $security }}Auth is responsible for extracting "{{$security}}" credentials from a request and calling the
// supplied Authenticator to authenticate
{{ goDoc $value.Value.Description }}
func {{ pascal $security }}Auth(fn {{if eq $value.Value.Scheme "basic"}}Basic{{end}}Authenticator) HttpAuthFunc {
    return func (r *http.Request) (*{{ $.CheckPackage $.Params.Auth $packageName }}, error){
    {{- if eq $value.Value.Type "apiKey" }}
        {{- if eq $value.Value.In "query" }}
        q := r.URL.Query()
        key := q.Get("{{$value.Value.Name}}")
        if len(b) == 0 {
            return nil, httputil.ErrUnauthorized
        }
        {{- else if eq $value.Value.In "header" }}
        b := r.Header.Get("{{$value.Value.Name}}")
        if len(b) == 0 {
            return nil, httputil.ErrUnauthorized
        }

        key := string(b)
        {{- else if eq $value.Value.In "cookie" }}
        cookie
        b, _ := r.Cookie(("{{$value.Value.Name}}")
        if len(b) == 0 {
            return nil, httputil.ErrUnauthorized
        }

        key := string(b)
        {{end}}

        return fn(key)
    {{- else if eq $value.Value.Type "http" }}
        {{- if eq $value.Value.Scheme "bearer" }}
        b := r.Header.Get("Authorization")
        if len(b) == 0 {
            return nil, httputil.ErrUnauthorized
        }

        // TODO: Option for strict header
        if bytes.HasPrefix(b, bearerAuthPrefix){
            b = b[7:]
        }

        return fn(string(b))
        {{- else if eq $value.Value.Scheme "basic" }}
        b := r.Header.Get("Authorization")
        if len(b) == 0 {
            return nil, httputil.ErrBasicAuthenticate
        }

        payload, err := base64.StdEncoding.DecodeString(string(b[len(basicAuthPrefix):]))
        if err != nil {
            return nil, httputil.ErrUnauthorized
        }

        pair := bytes.SplitN(payload, []byte(":"), 2)
        if len(pair) != 2 {
            return nil, httputil.ErrUnauthorized
        }

        return fn(string(pair[0]),string(pair[1]))
        {{- end }}
    {{- else  }}
        // TODO: Support: {{ toJson $value }}
        return nil, httputil.ErrUnauthorized
    {{- end }}
    }
}
{{- end }}

{{- if $.HasComplexAuth }}

// Complex Auth Support
{{- if .HasAuthorization -}}
// Scope is the individual security attribute to check for authorization
type Scope = string

// Scopes is the collection
type Scopes = []string

type AuthCheck struct {
    fn HttpAuthFunc
    Scopes
}
{{ else }}
type AuthCheck struct {
    fn HttpAuthFunc
}

{{ end }}
type SecurityGroup map[string]AuthCheck

type SecurityGroups  []SecurityGroup

type AuthResults map[string] *{{ $.CheckPackage $.Params.Auth $packageName }}

func (s SecurityGroup) Add(name string, fn HttpAuthFunc
{{- if .HasAuthorization -}}
, scopes ...string
{{- end -}}
) SecurityGroup{
	s[name] = AuthCheck{ fn: fn
{{- if .HasAuthorization -}}
, Scopes: scopes
{{- end -}}
}

	return s
}

func NewSecurityGroups(groups ...SecurityGroup) SecurityGroups{
	return groups
}

func doAuthorize(r *http.Request,
{{- if .HasAuthorization -}}
    authorize Authorizer,
{{- end -}}
    groups ...SecurityGroup) (*{{ $.CheckPackage $.Params.Auth $packageName }}, error){

	var user *{{ $.CheckPackage $.Params.Auth $packageName }}
	var err error

	users := AuthResults{}

    authorizeGroup := func (group SecurityGroup)(*{{ $.CheckPackage $.Params.Auth $packageName }}, error){
		for name, check := range group {
			user,ok := users[name]
			if !ok {
				user, err = check.fn(r)
				if err != nil {
					return nil, err
				}

				users[name] = user
			}
{{- if .HasAuthorization }}

			if len(check.Scopes) > 0 {
				err = authorize(user, check.Scopes...)
				if err != nil {
					return nil, err
				}
			}
{{ end -}}
		}

		return user, nil
	}

	for _, group := range groups {
		user, err := authorizeGroup(group)
		if err == nil {
			return user, nil
		}
	}

	return nil, err
}

{{- end }}
