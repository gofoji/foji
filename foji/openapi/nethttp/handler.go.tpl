{{- define "methodSignature"}}
	{{- if not (empty ($.OpSecurity .RuntimeParams.op)) -}}
		user *{{ $.CheckPackage $.Params.Auth "http" -}},
	{{- end }}
	{{- range $param := .RuntimeParams.op.Parameters -}}
		{{ camel $param.Value.Name }}  {{ if and (not $param.Value.Required) (not (eq $param.Value.Schema.Value.Type "array")) }}*{{ end }}{{ $.GetType $.PackageName "" $param.Value.Schema }},
	{{- end -}}
	{{- $body := .RuntimeParams.op.RequestBody}}
	{{- if isNotNil $body}}
        {{- $jsonBody := (index $body.Value.Content "application/json")}}
        {{- if isNotNil $jsonBody}}
            {{- $bodySchema := $jsonBody.Schema}}
            {{- if notEmpty $bodySchema.Ref }}

            {{- $type := $.GetTypeName $.PackageName $bodySchema}}
            {{- camel $type}} *{{ $type -}}
            {{- else }}

            {{- $type := $.GetType $.PackageName "" $jsonBody.Schema}}
            {{- camel $type}} *{{ $type -}}
            {{- end }}
        {{- end -}}
	{{- end -}}
	) (
	{{- $response := $.GetOpHappyResponseType $.PackageName .RuntimeParams.op}}
	{{- if notEmpty $response}} {{$response}},
	{{- end -}}
	 error)
{{- end -}}

{{- define "paramExtractionFunc" -}}
	{{- $source := .RuntimeParams.source }}
	{{- $type := .RuntimeParams.type }}
	{{- pascal $source -}}
	{{- if eq $type "[]string" -}}Strings
	{{- else }}{{pascal $type}}{{end -}}
{{- end -}}

{{- define "paramExtraction" -}}
	{{- $param := .RuntimeParams.param }}
	{{- $goType := ($.GetType "" $param.Value.Name $param.Value.Schema) }}
	{{- $required := $param.Value.Required }}

	{{ camel $param.Value.Name }} := mux.Vars(r)["{{ $param.Value.Name }}"]
		{{- if $required }}
	if len({{ camel $param.Value.Name }}) <= 0 {
		h.errorHandler(w, r, validation.New("{{ $param.Value.Name }}", "{{ camel $param.Value.Name }} parameter not found"))
		return
	}
		{{- end }}
{{- end -}}

// Code generated by foji {{ version }}, template: {{ templateFile }}; DO NOT EDIT.

package {{ .PackageName }}

import (
	"net/http"

	"github.com/bir/iken/httputil"
	"github.com/bir/iken/validation"
	"github.com/gorilla/mux"
)

type Service interface {
{{- range $name, $path := .API.Paths }}
	{{- range $verb, $op := $path.Operations }}
	{{ pascal $op.OperationID}}(r *http.Request,
	{{- template "methodSignature" ($.WithParams "op" $op) }}
	{{- end }}
{{- end }}
}

type OpenAPIHandlers struct {
	service      Service
	errorHandler httputil.ErrorHandlerFunc
	{{- range $security, $value := .API.Components.SecuritySchemes }}
	{{ camel $security }}Auth HttpAuthFunc
	{{- end }}
	{{- if .HasAuthorization }}
	authorize Authorizer
	{{- end}}
{{- range $name, $path := .API.Paths }}
	{{- range $verb, $op := $path.Operations }}
		{{- if not ($.IsSimpleAuth $op) }}
	{{ camel $op.OperationID}}AuthGroups SecurityGroups
		{{- end}}
	{{- end}}
{{- end}}
}

func RegisterHTTP(svc Service, r *mux.Router, e httputil.ErrorHandlerFunc
{{- $hasSecurity := false -}}
{{- range $security, $value := .API.Components.SecuritySchemes -}}
	, {{ camel $security }}Auth
{{- $hasSecurity = true -}}
{{- end -}}
{{- if $hasSecurity }} HttpAuthFunc {{- end -}}
{{- if .HasAuthorization -}}
	, authorize Authorizer
{{- end -}}
) *OpenAPIHandlers {
    s := OpenAPIHandlers{service: svc, errorHandler: e
{{- range $security, $value := .API.Components.SecuritySchemes -}}
	,{{ camel $security }}Auth: {{ camel $security }}Auth
{{- end -}}
	{{- if .HasAuthorization }}, authorize: authorize{{- end -}}
}

{{- range $name, $path := .API.Paths }}

	{{ range $verb, $op := $path.Operations }}
		r.Methods("{{upper $verb}}").Path("{{$name}}").Handler(http.HandlerFunc(s.{{ pascal $op.OperationID}}))
	{{- end }}
{{- end }}

{{- range $name, $path := .API.Paths }}
	{{ range $verb, $op := $path.Operations }}
		{{- if not ($.IsSimpleAuth $op) }}
			s.{{ camel $op.OperationID}}AuthGroups = NewSecurityGroups(
			{{- $securityList := $.OpSecurity $op }}
			{{- range $securityGroup := $securityList -}}
				SecurityGroup{}
				{{- range $security, $scopes := $securityGroup -}}
					.Add("{{camel $security}}",{{camel $security}}Auth
					{{- if not (empty $scopes) -}}
						{{- range $scopes -}}
						, "{{.}}"
						{{- end -}}
					{{- end -}}
					)
				{{- end -}}
			{{- end -}})
		{{- end}}
	{{- end}}
{{- end}}

	return &s
}

func (h *OpenAPIHandlers) doJSONWrite(w http.ResponseWriter, r *http.Request, code int, obj interface{}) {
	if err := httputil.JSONWrite(w, code, obj); err != nil {
		h.errorHandler(w, r, err)
	}
}

{{- range $name, $path := .API.Paths }}
	{{- range $verb, $op := $path.Operations }}

func (h *OpenAPIHandlers) {{ pascal $op.OperationID}}(w http.ResponseWriter, r *http.Request) {
{{- $securityList := $.OpSecurity $op }}
	var (
{{- if not (empty $securityList)}}
		authUser *{{ $.CheckPackage $.Params.Auth "http" }}
{{- end}}
		err error
	)

    r = r.WithContext(httputil.SetOp(r.Context(), "{{$op.OperationID}}"))


{{- if $.IsSimpleAuth $op }}

{{- $lastAuth := "" }}
	{{- range $securityGroup := $securityList }}
		{{- range $security, $scopes := $securityGroup }}
			{{- if eq $lastAuth $security }}
			{{- else }}


	authUser, err = h.{{ camel $security }}Auth(r)
	{{- $lastAuth = $security }}
			{{- end}}
		{{- end}}
	{{- end}}

{{- $authCt := 0 }}
	{{- range $securityGroup := $securityList }}
		{{- range $security, $scopes := $securityGroup }}
			{{- if not (empty $scopes) }}
				{{- if eq $authCt 0 }}
	if err == nil {
				{{- else }}
	if err != nil {
				{{- end }}
		err = h.authorize(authUser{{range $scopes}}, "{{.}}"{{end}})
	{{- $authCt = inc $authCt }}
			{{- end}}
		{{- end}}
	{{- end}}
{{ repeat $authCt "}\n" }}
{{- else }}
	authUser, err = doAuthorize(r, {{- if $.HasAuthorization }}h.authorize,{{end}} h.{{ camel $op.OperationID}}AuthGroups...)
{{- end}}
{{- if $.HasAnyAuth $op }}

	if err != nil {
		h.errorHandler(w, r, err)
		return
	}

	{{- if $.RequiresAuthUser $op }}
	if authUser == nil {
		h.errorHandler(w, r, httputil.ErrUnauthorized)
		return
	}
	{{- end}}
{{- end}}

		{{- range $param := $op.Parameters }}
			{{- template "paramExtraction" ($.WithParams "param" $param) }}
		{{- end }}

	{{- $hasBody := false}}

	{{- $body := $op.RequestBody}}
	{{- if isNotNil $body}}
    {{- $jsonBody := (index $body.Value.Content "application/json")}}
    {{- if isNotNil $jsonBody}}
	{{- $hasBody = true}}

    {{- $bodySchema := $jsonBody.Schema}}
    {{- if notEmpty $bodySchema.Ref }}

	body, err := {{ $.GetTypeName $.PackageName $bodySchema }}FromRequest(r)
    {{- else }}

	body, err := {{ $.GetType .PackageName "" $bodySchema }}FromRequest(r)
    {{- end }}
    if err != nil {
        h.errorHandler(w, r, err)
        return
    }
    {{- end }}
    {{- end }}

	{{- $response := $.GetOpHappyResponseType "http" $op}}
	{{- if notEmpty $response}}

	response, err := h.service.{{ pascal $op.OperationID}}(r,
	{{- else}}

	err = h.service.{{ pascal $op.OperationID}}(r,
	{{- end}}
	{{- if not (empty $securityList) -}}
		authUser,
	{{- end -}}
	{{- range $param := $op.Parameters -}}
		{{ if and (not $param.Value.Required) (not (eq $param.Value.Schema.Value.Type "array")) }}&{{ end }}{{ camel $param.Value.Name }},
	{{- end -}}
	{{- if $hasBody -}}
		body
	{{- end -}}

	)
	if err != nil {
		h.errorHandler(w, r, err)
		return
	}

{{- /*	// TODO: ? Response.Header.Set("Access-Control-Allow-Origin", "*")*/}}
{{- /*	// TODO: Code/Encoding based on response*/}}
	{{- $key := $.GetOpHappyResponseKey $op }}
	{{- if notEmpty $response }}

	h.doJSONWrite(w, r, {{$key}}, response)
	{{- else }}

	w.WriteHeader({{$key}})
	{{- end }}
}
	{{- end }}
{{- end }}
