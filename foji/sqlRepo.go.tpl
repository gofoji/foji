// Code generated by foji {{ version }}, template: {{ templateFile }}; DO NOT EDIT.

package  {{  $.PackageName }}

import (
	"context"
	"fmt"

{{- range .Imports }}
	"{{ . }}"
{{- end }}
)

{{- range .Queries }}
{{ $resultType := default (print .Name "Result") ($.GetType .Result.TypeParam $.PackageName) }}

{{- if .Result.GenerateType }}
// {{$resultType}} represents a result from '{{.Name}}'.
type {{$resultType}} struct {
{{- range .Result.Params.ByOrdinal }}
	{{ pascal .Name }} {{ $.GetType . $.PackageName }}  `json:"{{ .Name }},omitempty"` // postgres type: {{ .Type }} {{- if .Nullable }} NULLABLE {{ end }}
{{- end }}
}
{{- end }}

// {{.Name}} returns {{ $resultType }}.
{{- goDoc .Comment}}
func (r Repo) {{ .Name }}(ctx context.Context{{if gt (len .Params) 0}}, {{end -}}
	{{ $.Parameterize .Params.ByOrdinal "%s %s" $.PackageName }}) ({{ if .IsType "query" "arrayBasic" }}[]{{ end -}}
	{{$resultType}}, error) {
	const query = `{{ backQuote .SQL }}`

{{- if .IsType "query" }}

	q, err := r.db.Query(ctx, query{{if gt (len .Params) 0}}, {{ csv (.Params.ByQuery.Names.Camel)}}{{end}})
	if err != nil {
		return nil, fmt.Errorf("{{.Name}}.Query:%w", err)
	}

	var out []{{$resultType}}

	for q.Next() {
		row := {{ $resultType }}{}
		err := q.Scan({{ csv (.Result.Params.ByQuery.Names.Pascal.Sprintf "&row.%s")}})
		if err != nil {
			return nil, fmt.Errorf("{{.Name}}.Scan:%w", err)
		}

		out = append(out, row)
	}

	return out, nil
{{- else if .IsType "arrayBasic" }}
{{/*  Returns an array of basic type, e.g. []int  */}}
	q, err := r.db.Query(ctx, query{{if gt (len .Params) 0}}, {{ csv (.Params.ByQuery.Names.Camel)}}{{end}})
	if err != nil {
		return nil, fmt.Errorf("{{.Name}}.Query:%w", err)
	}

	var out []{{$resultType}}

	for q.Next() {
		var row {{ $resultType }}
		err := q.Scan(&row)
		if err != nil {
			return nil, fmt.Errorf("{{.Name}}.Scan:%w", err)
		}

		out = append(out, row)
	}

	return out, nil
{{- else }}
	rows, err := r.db.Query(ctx, query{{if gt (len .Params) 0}}, {{ csv (.Params.ByQuery.Names.Camel) }}{{end}})
	if err != nil {
		return {{ $resultType }}{}, fmt.Errorf("{{.Name}}:%w", err)
	}

	out, err := pgx.CollectOneRow(rows, pgx.RowToStructByName[{{$resultType}}])
	if errors.Is(pgx.ErrNoRows, err) {
        return {{ $resultType }}{}, nil
    }
	if err != nil {
	    return {{ $resultType }}{}, fmt.Errorf("{{.Name}}.RowTo:%w", err)
    }

	return out, nil
{{- end }}
}
{{- end }}
