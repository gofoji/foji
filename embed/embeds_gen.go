// Code generated by foji 0.4, template: foji/embed.go.tpl; DO NOT EDIT.

package embed

import "os"

func List() []string {
	return []string{
		"foji/dbList.console.tpl",
		"foji/embed.go.tpl",
		"foji/enum.go.tpl",
		"foji/fields.go.tpl",
		"foji/sqlRepo.go.tpl",
		"foji/openapi/auth.go.tpl",
		"foji/openapi/docs.go.tpl",
		"foji/openapi/error.go.tpl",
		"foji/openapi/handler.go.tpl",
		"foji/openapi/main.go.tpl",
		"foji/openapi/model.go.tpl",
		"foji/openapi/service.go.tpl",
		"foji/openapi/stub.yaml.tpl",
		"foji/pgx/db.go.tpl",
		"foji/pgx/model.go.tpl",
		"foji/pgx/table.go.tpl",
		"foji.yaml",
		"init.yaml",
	}
}

func Get(filename string) ([]byte, error) {
	switch filename {
	case "foji/dbList.console.tpl":
		return FojiSlashDbListDotConsoleDotTplBytes, nil
	case "foji/embed.go.tpl":
		return FojiSlashEmbedDotGoDotTplBytes, nil
	case "foji/enum.go.tpl":
		return FojiSlashEnumDotGoDotTplBytes, nil
	case "foji/fields.go.tpl":
		return FojiSlashFieldsDotGoDotTplBytes, nil
	case "foji/sqlRepo.go.tpl":
		return FojiSlashSqlRepoDotGoDotTplBytes, nil
	case "foji/openapi/auth.go.tpl":
		return FojiSlashOpenapiSlashAuthDotGoDotTplBytes, nil
	case "foji/openapi/docs.go.tpl":
		return FojiSlashOpenapiSlashDocsDotGoDotTplBytes, nil
	case "foji/openapi/error.go.tpl":
		return FojiSlashOpenapiSlashErrorDotGoDotTplBytes, nil
	case "foji/openapi/handler.go.tpl":
		return FojiSlashOpenapiSlashHandlerDotGoDotTplBytes, nil
	case "foji/openapi/main.go.tpl":
		return FojiSlashOpenapiSlashMainDotGoDotTplBytes, nil
	case "foji/openapi/model.go.tpl":
		return FojiSlashOpenapiSlashModelDotGoDotTplBytes, nil
	case "foji/openapi/service.go.tpl":
		return FojiSlashOpenapiSlashServiceDotGoDotTplBytes, nil
	case "foji/openapi/stub.yaml.tpl":
		return FojiSlashOpenapiSlashStubDotYamlDotTplBytes, nil
	case "foji/pgx/db.go.tpl":
		return FojiSlashPgxSlashDbDotGoDotTplBytes, nil
	case "foji/pgx/model.go.tpl":
		return FojiSlashPgxSlashModelDotGoDotTplBytes, nil
	case "foji/pgx/table.go.tpl":
		return FojiSlashPgxSlashTableDotGoDotTplBytes, nil
	case "foji.yaml":
		return FojiDotYamlBytes, nil
	case "init.yaml":
		return InitDotYamlBytes, nil
	}

	return nil, os.ErrNotExist
}

func GetString(filename string) (string, error) {
	switch filename {
	case "foji/dbList.console.tpl":
		return FojiSlashDbListDotConsoleDotTpl, nil
	case "foji/embed.go.tpl":
		return FojiSlashEmbedDotGoDotTpl, nil
	case "foji/enum.go.tpl":
		return FojiSlashEnumDotGoDotTpl, nil
	case "foji/fields.go.tpl":
		return FojiSlashFieldsDotGoDotTpl, nil
	case "foji/sqlRepo.go.tpl":
		return FojiSlashSqlRepoDotGoDotTpl, nil
	case "foji/openapi/auth.go.tpl":
		return FojiSlashOpenapiSlashAuthDotGoDotTpl, nil
	case "foji/openapi/docs.go.tpl":
		return FojiSlashOpenapiSlashDocsDotGoDotTpl, nil
	case "foji/openapi/error.go.tpl":
		return FojiSlashOpenapiSlashErrorDotGoDotTpl, nil
	case "foji/openapi/handler.go.tpl":
		return FojiSlashOpenapiSlashHandlerDotGoDotTpl, nil
	case "foji/openapi/main.go.tpl":
		return FojiSlashOpenapiSlashMainDotGoDotTpl, nil
	case "foji/openapi/model.go.tpl":
		return FojiSlashOpenapiSlashModelDotGoDotTpl, nil
	case "foji/openapi/service.go.tpl":
		return FojiSlashOpenapiSlashServiceDotGoDotTpl, nil
	case "foji/openapi/stub.yaml.tpl":
		return FojiSlashOpenapiSlashStubDotYamlDotTpl, nil
	case "foji/pgx/db.go.tpl":
		return FojiSlashPgxSlashDbDotGoDotTpl, nil
	case "foji/pgx/model.go.tpl":
		return FojiSlashPgxSlashModelDotGoDotTpl, nil
	case "foji/pgx/table.go.tpl":
		return FojiSlashPgxSlashTableDotGoDotTpl, nil
	case "foji.yaml":
		return FojiDotYaml, nil
	case "init.yaml":
		return InitDotYaml, nil
	}

	return "", os.ErrNotExist
}

var FojiSlashDbListDotConsoleDotTplBytes = []byte(FojiSlashDbListDotConsoleDotTpl)

const FojiSlashDbListDotConsoleDotTpl = `{{- range $key, $value := .DB -}}
Schema: {{red}}{{$key}}{{colorReset}}
{{- range $value.Tables }}
  {{ pascal .Type }}: {{yellow}}{{ case .Name }}{{colorReset}}
  {{- if .ReadOnly }}  {{red}}readonly{{colorReset}} {{end}}
  {{- magenta}}  {{ .Comment }}{{colorReset}}
    Columns{{range .Columns }}
      {{green}}{{ pad (case .Name) (cases .Table.Columns.Names).Max }} {{colorReset}}  {{ pad .Type .Table.Columns.Types.Max }}  {{ if not .Nullable }}NOT NULL{{end}}  {{ if .IsPrimaryKey }}PK{{end}} {{magenta}}{{ .Comment }}{{colorReset}}
    {{- end }}
    {{- if not (empty .Indexes)}}
    Indexes{{range .Indexes }}
      {{ case .Name }} {{ (cases .Columns.Names).Join "," }} {{ if not .IsUnique }}UNIQUE{{end}} {{ if .IsPrimary }}{{cyan}}PK{{colorReset}}{{end}} {{magenta}}{{ .Comment }}{{colorReset}}
    {{- end }}{{end}}
    {{- if not (empty .ForeignKeys)}}
    ForeignKeys{{range .ForeignKeys }}
      {{ case .Name }} ({{ (cases .Columns.Names).Join "," }}) -> {{ case .ForeignTable.Name }}({{ (cases .ForeignColumns.Names).Join "," }}) {{magenta}}{{ .Comment }}{{colorReset}}
    {{- end }}{{end}}
    {{- if not (empty .References)}}
    References{{range .References }}
      {{ case .Name }} {{ .Table.Name }}({{ (cases .Columns.Names).Join "," }}) -> ({{ (cases .ForeignColumns.Names).Join "," }}) {{magenta}}{{ .Comment }}{{colorReset}}
    {{- end }}{{end}}
{{ end }}
{{- range $value.Enums }}
  enum: {{yellow}}{{ case .Name }}{{colorReset}} {{magenta}}{{ .Comment }}{{colorReset}}
    {{- range .Values }}
      {{green}}{{ case . }}{{colorReset}}
    {{- end }}
{{- end }}
{{- end }}`

var FojiSlashEmbedDotGoDotTplBytes = []byte(FojiSlashEmbedDotGoDotTpl)

const FojiSlashEmbedDotGoDotTpl = `// Code generated by foji {{ version }}, template: {{ templateFile }}; DO NOT EDIT.

package {{ .Params.PackageName }}

import "os"

func List() []string {
	return []string{
{{- range .FileGroups }}
	{{- range .Files }}
		"{{ .Name }}",
	{{- end }}
{{- end}}
		}
}

func Get(filename string) ([]byte, error) {
	switch filename {
{{- range .FileGroups }}
{{- range .Files }}
	case "{{ .Name }}":
		return {{ case (goToken .Name) }}Bytes, nil
{{- end }}
{{- end}}
	}

	return nil, os.ErrNotExist
}

func GetString(filename string) (string, error) {
	switch filename {
{{- range .FileGroups }}
{{- range .Files }}
	case "{{ .Name }}":
		return {{ case (goToken .Name) }}, nil
{{- end }}
{{- end}}
	}

	return "", os.ErrNotExist
}
{{- range .FileGroups }}
{{- range .Files }}

var {{ case (goToken .Name) }}Bytes = []byte({{ case (goToken .Name) }})
const {{ case (goToken .Name) }} = ` + "`" + `{{ backQuote .Content }}` + "`" + `
{{- end -}}
{{end -}}`

var FojiSlashEnumDotGoDotTplBytes = []byte(FojiSlashEnumDotGoDotTpl)

const FojiSlashEnumDotGoDotTpl = `// Code generated by foji {{ version }}, template: {{ templateFile }}; DO NOT EDIT.

package enum

import (
	"database/sql/driver"

	"{{.Params.Package}}"
	"github.com/pkg/errors"
)

{{- $type := case .Enum.Name }}

// {{ $type }} is the '{{ .Enum.Name }}' enum type from schema '{{ .Enum.Schema.Name  }}'.
type {{ $type }} uint16

const (
	// Unknown{{$type}} defines an invalid {{$type}}.
	Unknown{{$type}} {{$type}} = iota
{{- range .Enum.Values }}
	{{ case . }}{{ $type }}
{{- end }}
)

// String returns the string value of the {{ $type }}.
func (e {{ $type }}) String() string {
	switch e {
{{- range .Enum.Values }}
	case {{ case . }}{{ $type }}:
		return "{{ . }}"
{{- end }}
	default:
		return "Unknown{{$type}}"
	}
}

// MarshalText marshals {{ $type }} into text.
func (e {{ $type }}) MarshalText() ([]byte, error) {
	return []byte(e.String()), nil
}

// UnmarshalText unmarshals {{ $type }} from text.
func (e *{{ $type }}) UnmarshalText(text []byte) error {
	val, err := Parse{{$type}}(string(text))
	if err != nil {
		return err
	}
	*e = val
	return nil
}

// Parse{{$type}} converts s into a {{$type}} if it is a valid
// stringified value of {{$type}}.
func Parse{{$type}}(s string) ({{$type}}, error) {
	switch s {
{{- range .Enum.Values }}
	case "{{ . }}":
		return {{ case . }}{{ $type }}, nil
{{- end }}
	default:
		return Unknown{{$type}}, errors.New("invalid {{ $type }}")
	}
}

// Value satisfies the sql/driver.Valuer interface for {{ $type }}.
func (e {{ $type }}) Value() (driver.Value, error) {
	return e.String(), nil
}

// Scan satisfies the database/sql.Scanner interface for {{ $type }}.
func (e *{{ $type }}) Scan(src interface{}) error {
	buf, ok := src.([]byte)
	if !ok {
		return errors.New("invalid {{ $type }}")
	}

	return e.UnmarshalText(buf)
}

// {{$type}}Field is a component that returns a {{ $.PackageName }}.Where that contains a
// comparison based on its field and a strongly typed value.
type {{$type}}Field string

// Equals returns a {{$.PackageName}}.WhereClause for this field.
func (f {{$type}}Field) Equals(v {{$type}}) {{$.PackageName}}.Where {
	return {{$.PackageName}}.Where{
		Field: string(f),
		Comp:  {{$.PackageName}}.CompEqual,
		Value: v,
	}
}

// GreaterThan returns a {{$.PackageName}}.Where for this field.
func (f {{$type}}Field) GreaterThan(v {{$type}}) {{$.PackageName}}.Where {
	return {{$.PackageName}}.Where{
		Field: string(f),
		Comp:  {{$.PackageName}}.CompGreater,
		Value: v,
	}
}

// LessThan returns a {{$.PackageName}}.Where for this field.
func (f {{$type}}Field) LessThan(v {{$type}}) {{$.PackageName}}.Where {
	return {{$.PackageName}}.Where{
		Field: string(f),
		Comp:  {{$.PackageName}}.CompEqual,
		Value: v,
	}
}

// GreaterOrEqual returns a {{$.PackageName}}.Where for this field.
func (f {{$type}}Field) GreaterOrEqual(v {{$type}}) {{$.PackageName}}.Where {
	return {{$.PackageName}}.Where{
		Field: string(f),
		Comp:  {{$.PackageName}}.CompGTE,
		Value: v,
	}
}

// LessOrEqual returns a {{$.PackageName}}.Where for this field.
func (f {{$type}}Field) LessOrEqual(v {{$type}}) {{$.PackageName}}.Where {
	return {{$.PackageName}}.Where{
		Field: string(f),
		Comp:  {{$.PackageName}}.CompLTE,
		Value: v,
	}
}

// NotEqual returns a {{$.PackageName}}.Where for this field.
func (f {{$type}}Field) NotEqual(v {{$type}}) {{$.PackageName}}.Where {
	return {{$.PackageName}}.Where{
		Field: string(f),
		Comp:  {{$.PackageName}}.CompNE,
		Value: v,
	}
}

// In returns a {{$.PackageName}}.Where for this field.
func (f {{$type}}Field) In(vals []{{$type}}) {{$.PackageName}}.InClause {
	values := make([]interface{}, len(vals))
	for x := range vals {
		values[x] = vals[x]
	}
	return {{$.PackageName}}.InClause{
		Field: string(f),
		Vals:  values,
	}
}
`

var FojiSlashFieldsDotGoDotTplBytes = []byte(FojiSlashFieldsDotGoDotTpl)

const FojiSlashFieldsDotGoDotTpl = `// Code generated by foji {{ version }}, template: {{ templateFile }}; DO NOT EDIT.

package {{ .PackageName }}

import (
	"bytes"
	"database/sql"
	"database/sql/driver"
	"encoding/json"
	"fmt"
	"strconv"
	"strings"
	"time"

	"github.com/google/uuid"
	"github.com/pkg/errors"
)


// Bytea is a wrapper around byte arrays specifically for bytea column types in postgres.
type Bytea []byte

// Jsonb is a wrapper for map[string]interface{} for storing json into postgres
type Jsonb map[string]interface{}

// Value marshals the json into the database
func (j Jsonb) Value() (driver.Value, error) {
	return json.Marshal(j)
}

// Scan Unmarshalls the bytes[] back into a Jsonb object
func (j *Jsonb) Scan(src interface{}) error {
	source, ok := src.([]byte)
	if !ok {
		return errors.New("Type assertion .([]byte) failed")
	}

	var i interface{}
	err := json.Unmarshal(source, &i)
	if err != nil {
		return err
	}

	if i == nil {
		return nil
	}

	*j, ok = i.(map[string]interface{})
	if !ok {
		return errors.New("reading from DB into Jsonb, failed to convert to map[string]interface{}")
	}

	return nil
}

type OrderByClause interface {
	String() string
}

// OrderByDesc returns a sort order descending by the given field.
func OrderByDesc(field string) OrderBy {
	return OrderBy{
		Field: field,
		Order: OrderDesc,
	}
}

// OrderByAsc returns a sort order ascending by the given field.
func OrderByAsc(field string) OrderBy {
	return OrderBy{
		Field: field,
		Order: OrderAsc,
	}
}

// OrderBy indicates how rows should be sorted.
type OrderBy struct {
	Field string
	Order SortOrder
}

func (o OrderBy) String() string {
	if o.Order == OrderNone {
		return ""
	}
	return " ORDER BY " + o.Field + " " + o.Order.String() + " "
}

// SortOrder defines how to order rows returned.
type SortOrder int

// Defined sort orders for not sorted, descending and ascending.
const (
	OrderNone SortOrder = iota
	OrderDesc
	OrderAsc
)

// String returns the sql string representation of this sort order.
func (s SortOrder) String() string {
	switch s {
	case OrderDesc:
		return "DESC"
	case OrderAsc:
		return "ASC"
	}
	return ""
}

// WhereClause has a String function should return a properly formatted where
// clause (not including the WHERE) for positional arguments starting at idx.
type WhereClause interface {
	String(idx *int) string
	Values() []interface{}
}

// Comparison is used by WhereClauses to create valid sql.
type Comparison string

// Comparison types.
const (
	CompEqual   Comparison = " = "
	CompGreater Comparison = " > "
	CompLess    Comparison = " < "
	CompGTE     Comparison = " >= "
	CompLTE     Comparison = " <= "
	CompNE      Comparison = " <> "
)

type Where struct {
	Field string
	Comp  Comparison
	Value interface{}
}

func (w Where) String(idx *int) string {
	ret := w.Field + string(w.Comp) + "$" + strconv.Itoa(*idx)
	(*idx)++
	return ret
}

func (w Where) Values() []interface{} {
	return []interface{}{w.Value}
}

// NullClause is a clause that checks for a column being null or not.
type NullClause struct {
	Field string
	Null  bool
}

func (n NullClause) String(_ *int) string {
	if n.Null {
		return n.Field + " IS NULL "
	}
	return n.Field + " IS NOT NULL "
}

func (n NullClause) Values() []interface{} {
	return []interface{}{}
}

// AndClause returns a WhereClause that serializes to the AND
// of all the given where clauses.
func AndClause(wheres ...WhereClause) WhereClause {
	return andClause(wheres)
}

type andClause []WhereClause

func (a andClause) String(idx *int) string {
	wheres := make([]string, len(a))
	for x := 0; x < len(a); x++ {
		wheres[x] = a[x].String(idx)
	}
	return strings.Join(wheres, " AND ")
}

func (a andClause) Values() []interface{} {
	vals := make([]interface{}, 0, len(a))
	for x := 0; x < len(a); x++ {
		vals = append(vals, a[x].Values()...)
	}
	return vals
}

// OrClause returns a WhereClause that serializes to the OR
// of all the given where clauses.
func OrClause(wheres ...WhereClause) WhereClause {
	return orClause(wheres)
}

type orClause []WhereClause

func (o orClause) String(idx *int) string {
	wheres := make([]string, len(o))
	for x := 0; x < len(wheres); x++ {
		wheres[x] = o[x].String(idx)
	}
	return strings.Join(wheres, " OR ")
}

func (o orClause) Values() []interface{} {
	vals := make([]interface{}, len(o))
	for x := 0; x < len(o); x++ {
		vals = append(vals, o[x].Values()...)
	}
	return vals
}

// InClause takes a slice of values that it matches against.
type InClause struct {
	Field  string
	Vals []interface{}
}

func (in InClause) String(idx *int) string {
	ret := in.Field + " in ("
	for x := range in.Vals {
		if x != 0 {
			ret += ", "
		}
		ret += "$" + strconv.Itoa(*idx)
		(*idx)++
	}
	ret += ")"
	return ret
}

func (in InClause) Values() []interface{} {
	return in.Vals
}

type PrefixMatch struct {
	Field string
	Value interface{}
}

func (w PrefixMatch) String(idx *int) string {
	ret := "$" + strconv.Itoa(*idx) + " ILIKE " + w.Field
	(*idx)++
	return ret
}

func (w PrefixMatch) Values() []interface{} {
	return []interface{}{w.Value}
}


type PInt32 *int32
type PString *string

func NewPInt32(i int32) PInt32{
  return &i
}

// Time is a nullable time.Time. It supports SQL and JSON serialization.
// It will marshal to null if null.
type Time struct {
	sql.NullTime
}

// Value implements the driver Valuer interface.
func (t Time) Value() (driver.Value, error) {
	if !t.Valid {
		return nil, nil
	}
	return t.Time, nil
}

// TimeFrom creates a new Time that will always be valid.
func TimeFrom(t time.Time) Time {
	return Time{
		NullTime: sql.NullTime{
			Time:  t,
			Valid: true,
		},
	}
}

// MarshalJSON implements json.Marshaler.
// It will encode null if this time is null.
func (t Time) MarshalJSON() ([]byte, error) {
	if !t.Valid {
		return []byte("null"), nil
	}
	return t.Time.MarshalJSON()
}

// nullBytes is a JSON null literal
var nullBytes = []byte("null")

// UnmarshalJSON implements json.Unmarshaler.
// It supports string and null input.
func (t *Time) UnmarshalJSON(data []byte) error {
	if bytes.Equal(data, nullBytes) {
		t.Valid = false
		return nil
	}

	if err := json.Unmarshal(data, &t.Time); err != nil {
		return fmt.Errorf("null: couldn't unmarshal JSON: %w", err)
	}

	t.Valid = true
	return nil
}

// MarshalText implements encoding.TextMarshaler.
// It returns an empty string if invalid, otherwise time.Time's MarshalText.
func (t Time) MarshalText() ([]byte, error) {
	if !t.Valid {
		return []byte{}, nil
	}
	return t.Time.MarshalText()
}

// UnmarshalText implements encoding.TextUnmarshaler.
// It has backwards compatibility with v3 in that the string "null" is considered equivalent to an empty string
// and unmarshaling will succeed. This may be removed in a future version.
func (t *Time) UnmarshalText(text []byte) error {
	str := string(text)
	// allowing "null" is for backwards compatibility with v3
	if str == "" || str == "null" {
		t.Valid = false
		return nil
	}
	if err := t.Time.UnmarshalText(text); err != nil {
		return fmt.Errorf("null: couldn't unmarshal text: %w", err)
	}
	t.Valid = true
	return nil
}

// SetValid changes this Time's value and sets it to be non-null.
func (t *Time) SetValid(v time.Time) {
	t.Time = v
	t.Valid = true
}

// Ptr returns a pointer to this Time's value, or a nil pointer if this Time is null.
func (t Time) Ptr() *time.Time {
	if !t.Valid {
		return nil
	}
	return &t.Time
}

// IsZero returns true for invalid Times, hopefully for future omitempty support.
// A non-null Time with a zero value will not be considered zero.
func (t Time) IsZero() bool {
  return !t.Valid
}

// Equal returns true if both Time objects encode the same time or are both null.
// Two times can be equal even if they are in different locations.
// For example, 6:00 +0200 CEST and 4:00 UTC are Equal.
func (t Time) Equal(other Time) bool {
  return t.Valid == other.Valid && (!t.Valid || t.Time.Equal(other.Time))
}

// ExactEqual returns true if both Time objects are equal or both null.
// ExactEqual returns false for times that are in different locations or
// have a different monotonic clock reading.
func (t Time) ExactEqual(other Time) bool {
  return t.Valid == other.Valid && (!t.Valid || t.Time == other.Time)
}

{{ range (toSlice "PString" "PInt32" "Jsonb" "int" "int32" "string"  "int64" "float64" "bool"  "time.Time" "Time" "uint32" "uuid.UUID") }}
{{ $fieldName := title (replace "." "" .) }}// {{$fieldName}}Field is a component that returns a WhereClause that contains a
// comparison based on its field and a strongly typed value.
type {{$fieldName}}Field string

// OrderBy returns a OrderByClause for this field.
func (f {{$fieldName}}Field) OrderBy(v SortOrder) OrderByClause {
	return OrderBy{
		Field: string(f),
		Order:  v,
	}
}

// OrderByAsc returns a OrderByClause for this field.
func (f {{$fieldName}}Field) OrderByAsc() OrderByClause {
	return OrderBy{
		Field: string(f),
		Order:  OrderAsc,
	}
}

// OrderByDesc returns a OrderByClause for this field.
func (f {{$fieldName}}Field) OrderByDesc() OrderByClause {
	return OrderBy{
		Field: string(f),
		Order:  OrderDesc,
	}
}

// Equals returns a WhereClause for this field.
func (f {{$fieldName}}Field) Equals(v {{.}}) Where {
	return Where{
		Field: string(f),
		Comp:  CompEqual,
		Value: v,
	}
}

// GreaterThan returns a WhereClause for this field.
func (f {{$fieldName}}Field) GreaterThan(v {{.}}) Where {
	return Where{
		Field: string(f),
		Comp:  CompGreater,
		Value: v,
	}
}

// LessThan returns a WhereClause for this field.
func (f {{$fieldName}}Field) LessThan(v {{.}}) Where {
	return Where{
		Field: string(f),
		Comp:  CompLess,
		Value: v,
	}
}

// GreaterOrEqual returns a WhereClause for this field.
func (f {{$fieldName}}Field) GreaterOrEqual(v {{.}}) Where {
	return Where{
		Field: string(f),
		Comp:  CompGTE,
		Value: v,
	}
}

// LessOrEqual returns a WhereClause for this field.
func (f {{$fieldName}}Field) LessOrEqual(v {{.}}) Where {
	return Where{
		Field: string(f),
		Comp:  CompLTE,
		Value: v,
	}
}

// NotEqual returns a WhereClause for this field.
func (f {{$fieldName}}Field) NotEqual(v {{.}}) Where {
	return Where{
		Field: string(f),
		Comp:  CompNE,
		Value: v,
	}
}

// In returns a WhereClause for this field.
func (f {{$fieldName}}Field) In(vals ...{{.}}) InClause {
	values := make([]interface{}, len(vals))
	for x := range vals {
		values[x] = vals[x]
	}
	return InClause{
		Field: string(f),
		Vals: values,
	}
}

{{end}}

{{ range (toSlice  "PString" "PInt32" "Jsonb" "Time" ) }}
{{ $fieldName := title (replace "." "" .) }}
// IsNull returns a WhereClause that matches when this field is NULL.
func (f {{$fieldName}}Field) IsNull() NullClause {
	return NullClause{
		Field: string(f),
		Null: true,
	}
}

// IsNotNull returns a WhereClause that matches when this field is not NULL.
func (f {{$fieldName}}Field) IsNotNull() NullClause {
	return NullClause{
		Field: string(f),
		Null: false,
	}
}

{{end}}

// InterfaceField is a component that returns a WhereClause that contains a
// comparison based on its field and a strongly typed value.  Currently interface{} is not supported.
type InterfaceField string

`

var FojiSlashSqlRepoDotGoDotTplBytes = []byte(FojiSlashSqlRepoDotGoDotTpl)

const FojiSlashSqlRepoDotGoDotTpl = `// Code generated by foji {{ version }}, template: {{ templateFile }}; DO NOT EDIT.

package pg

import (
    "context"

    "github.com/pkg/errors"
    "{{.Params.Package}}"
{{- range .Imports }}
    "{{ . }}"
{{- end }}
)

{{- range .Queries }}
{{- $resultType := $.GetType .Result.TypeParam $.PackageName }}

{{- if .Result.GenerateType }}
// {{.Result.Type}} represents a result from '{{.Name}}'.
type {{.Result.Type}} struct {
{{- range .Result.Params.ByOrdinal }}
    {{ pascal .Name }} {{ $.GetType . $.PackageName }}  ` + "`" + `json:"{{ .Name }},omitempty"` + "`" + ` // {{ .Type }}
{{- end }}
}
{{- end }}

// {{.Name}} returns {{ $resultType }}
// {{.Comment}}
func (r Repo) {{ .Name }}(ctx context.Context{{if gt (len .Params) 0}},{{end}} {{ $.Parameterize .Params.ByOrdinal "%s %s" $.PackageName }}) ({{ if .IsType "query" }}[]{{ end }}*{{$resultType}}, error) {
    query := ` + "`" + `{{ backQuote .SQL }}` + "`" + `

    {{- if .IsType "query" }}
    q, err := r.db.Query(ctx, query{{if gt (len .Params) 0}},{{end}} {{ csv (.Params.ByQuery.Names.Camel)}})
    if err != nil {
        return nil, errors.Wrap(err, "{{.Name}}.Query")
    }
    var result []*{{ $resultType }}
    for q.Next() {
        row := {{ $resultType }}{}
        err := q.Scan({{ csv (.Result.Params.ByQuery.Names.Pascal.Sprintf "&row.%s")}})
        if err != nil {
            return nil, errors.Wrap(err, "{{ .Name }}.scan") // notest
        }
        result = append(result, &row)
    }

    return result, nil
    {{- else }}
    q := r.db.QueryRow(ctx, query{{if gt (len .Params) 0}},{{end}} {{ csv (.Params.ByQuery.Names.Camel) }})
        {{/*        return scanOne{{$goName}}(q)*/}}
    {{- end }}
}
{{- end }}
`

var FojiSlashOpenapiSlashAuthDotGoDotTplBytes = []byte(FojiSlashOpenapiSlashAuthDotGoDotTpl)

const FojiSlashOpenapiSlashAuthDotGoDotTpl = `{{ .NotNeededIf (empty .API.Components.SecuritySchemes) "no security schemes" -}}
{{ .ErrorIf (empty $.Params.Auth) "params.Auth" -}}
// Code generated by foji {{ version }}, template: {{ templateFile }}; DO NOT EDIT.
{{ $packageName := "http" }}
package {{$packageName}}

import (
    "bytes"
    "strings"
    "encoding/base64"

	"github.com/bir/iken/fastutil"
    "github.com/valyala/fasthttp"
)

// HttpAuthFunc is the signature of a function used to authenticate an http request.
// Given a request, it returns the authenticated user.  If unable to authenticate the
// request it returns an error.
type HttpAuthFunc = func(ctx *fasthttp.RequestCtx)(*{{ $.CheckPackage $.Params.Auth $packageName }}, error)

// Authenticator takes a key (for example a bearer token) and returns the authenticated user.
type Authenticator = func(key string) (*{{ $.CheckPackage $.Params.Auth $packageName }}, error)

{{- if .HasBasicAuth }}

// BasicAuthenticator takes a user/pass pair and returns the authenticated user.
type BasicAuthenticator = func(user,pass string) (*{{ $.CheckPackage $.Params.Auth $packageName }}, error)
{{- end}}

{{- if .HasAuthorization }}

// Authorizer is given an authenticated User and a list of scopes to validate.
type Authorizer = func(user *{{ $.CheckPackage $.Params.Auth $packageName }}, scopes ...string ) (error)
{{- end}}

{{- if or .HasBasicAuth .HasBearerAuth }}
var (
{{- if .HasBasicAuth }}
    basicAuthPrefix = []byte("Basic ")
{{- end}}
{{- if .HasBearerAuth }}
    bearerAuthPrefix = []byte("Bearer ")
{{- end}}
)
{{- end}}

{{- range $security, $value := .File.API.Components.SecuritySchemes }}

// {{ pascal $security }}Auth is responsible for extracting "{{$security}}" credentials from a request and calling the
// supplied Authenticator to authenticate
{{ goDoc $value.Value.Description }}
func {{ pascal $security }}Auth(fn {{if eq $value.Value.Scheme "basic"}}Basic{{end}}Authenticator) HttpAuthFunc {
    return func (ctx *fasthttp.RequestCtx) (*{{ $.CheckPackage $.Params.Auth $packageName }}, error){
    {{- if eq $value.Value.Type "apiKey" }}
        {{- if eq $value.Value.In "query" }}
        key, err := fastutil.QueryString(ctx, "{{$value.Value.Name}}")
        if err != nil {
            return nil, fastutil.ErrUnauthorized
        }
        {{- else if eq $value.Value.In "header" }}
        b := ctx.Request.Header.Peek("{{$value.Value.Name}}")
        if len(b) == 0 {
            return nil, fastutil.ErrUnauthorized
        }

        key := string(b)
        {{- else if eq $value.Value.In "cookie" }}
        b := string(ctx.Request.Header.Cookie("{{$value.Value.Name}}"))
        if len(b) == 0 {
            return nil, fastutil.ErrUnauthorized
        }

        key := string(b)
        {{end}}

        return fn(key)
    {{- else if eq $value.Value.Type "http" }}
        {{- if eq $value.Value.Scheme "bearer" }}
        b := ctx.Request.Header.Peek("Authorization")
        if len(b) == 0 {
            return nil, fastutil.ErrUnauthorized
        }

        // TODO: Option for strict header
        if bytes.HasPrefix(b, bearerAuthPrefix){
            b = b[7:]
        }

        return fn(string(b))
        {{- else if eq $value.Value.Scheme "basic" }}
        b := ctx.Request.Header.Peek("Authorization")
        if len(b) == 0 {
            return nil, fastutil.ErrBasicAuthenticate
        }

        payload, err := base64.StdEncoding.DecodeString(string(b[len(basicAuthPrefix):]))
        if err != nil {
            return nil, fastutil.ErrUnauthorized
        }

        pair := bytes.SplitN(payload, []byte(":"), 2)
        if len(pair) != 2 {
            return nil, fastutil.ErrUnauthorized
        }

        return fn(string(pair[0]),string(pair[1]))
        {{- end }}
    {{- else  }}
        // TODO: Support: {{ toJson $value }}
        return nil, fastutil.ErrUnauthorized
    {{- end }}
    }
}
{{- end }}

{{- if $.HasComplexAuth }}

// Complex Auth Support
{{- if .HasAuthorization -}}
// Scope is the individual security attribute to check for authorization
type Scope = string

// Scopes is the collection
type Scopes = []string

type AuthCheck struct {
    fn HttpAuthFunc
    Scopes
}
{{ else }}
type AuthCheck struct {
    fn HttpAuthFunc
}

{{ end }}
type SecurityGroup map[string]AuthCheck

type SecurityGroups  []SecurityGroup

type AuthResults map[string] *{{ $.CheckPackage $.Params.Auth $packageName }}

func (s SecurityGroup) Add(name string, fn HttpAuthFunc
{{- if .HasAuthorization -}}
, scopes ...string
{{- end -}}
) SecurityGroup{
	s[name] = AuthCheck{ fn: fn
{{- if .HasAuthorization -}}
, Scopes: scopes
{{- end -}}
}

	return s
}

func NewSecurityGroups(groups ...SecurityGroup) SecurityGroups{
	return groups
}

func doAuthorize(ctx *fasthttp.RequestCtx,
{{- if .HasAuthorization -}}
    authorize Authorizer,
{{- end -}}
    groups ...SecurityGroup) (*{{ $.CheckPackage $.Params.Auth $packageName }}, error){

	var user *{{ $.CheckPackage $.Params.Auth $packageName }}
	var err error

	users := AuthResults{}

    authorizeGroup := func (group SecurityGroup)(*{{ $.CheckPackage $.Params.Auth $packageName }}, error){
		for name, check := range group {
			user,ok := users[name]
			if !ok {
				user, err = check.fn(ctx)
				if err != nil {
					return nil, err
				}

				users[name] = user
			}
{{- if .HasAuthorization }}

			if len(check.Scopes) > 0 {
				err = authorize(user, check.Scopes...)
				if err != nil {
					return nil, err
				}
			}
{{ end -}}
		}

		return user, nil
	}

	for _, group := range groups {
		user, err := authorizeGroup(group)
		if err == nil {
			return user, nil
		}
	}

	return nil, err
}

{{- end }}
`

var FojiSlashOpenapiSlashDocsDotGoDotTplBytes = []byte(FojiSlashOpenapiSlashDocsDotGoDotTpl)

const FojiSlashOpenapiSlashDocsDotGoDotTpl = `// Code generated by foji {{ version }}, template: {{ templateFile }}; DO NOT EDIT.

package {{ .Params.PackageName }}

import (
	"net/http"

	"github.com/fasthttp/router"
	"github.com/valyala/fasthttp"
)

var (
	strApplicationHTML = []byte("text/html")
	reDocHTML          = []byte(` + "`" + `<!DOCTYPE html>
<html>
  <head>
    <title>{{ .Params.Title }}</title>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href="https://fonts.googleapis.com/css?family=Montserrat:300,400,700|Roboto:300,400,700" rel="stylesheet">
    <style>
      body {
        margin: 0;
        padding: 0;
      }
    </style>
  </head>
  <body>
    <redoc spec-url='swagger.yaml' {{ .Params.RedocOptions }} ></redoc>
    <script src="https://cdn.jsdelivr.net/npm/redoc@next/bundles/redoc.standalone.js"> </script>
  </body>
</html>` + "`" + `)
)

func Register(r *router.Router) {
	r.GET("/docs", GetHTML)
	r.GET("/swagger.yaml", GetYaml)
}

func GetHTML(ctx *fasthttp.RequestCtx) {
	ctx.Response.Header.SetContentTypeBytes(strApplicationHTML)
	_, err := ctx.Write(reDocHTML)
	if err != nil {
		ctx.Error(err.Error(), http.StatusInternalServerError)
	}
}

func GetYaml(ctx *fasthttp.RequestCtx) {

{{- range .FileGroups }}
	{{- range .Files }}
		_, err := ctx.Write({{ case (goToken .Name) }}Bytes)
	{{- end -}}
{{end }}
	if err != nil {
		ctx.Error(err.Error(), http.StatusInternalServerError)
		return
	}
}
`

var FojiSlashOpenapiSlashErrorDotGoDotTplBytes = []byte(FojiSlashOpenapiSlashErrorDotGoDotTpl)

const FojiSlashOpenapiSlashErrorDotGoDotTpl = `package http

import (
    "errors"

    "github.com/bir/iken/fastutil"
    "github.com/valyala/fasthttp"
    "{{ .Params.Package }}"
)

// ErrorHandler maps all error types into HTTP responses.  See fastutil.ErrorHandler for examples.
func ErrorHandler(ctx *fasthttp.RequestCtx, err error) {
    if errors.Is(err, {{ .PackageName }}.ErrNotImplemented) {
        ctx.Error("NOT IMPLEMENTED", fasthttp.StatusNotImplemented)

        return
    }

    // Add custom error handling here
    fastutil.ErrorHandler(ctx, err)
}
`

var FojiSlashOpenapiSlashHandlerDotGoDotTplBytes = []byte(FojiSlashOpenapiSlashHandlerDotGoDotTpl)

const FojiSlashOpenapiSlashHandlerDotGoDotTpl = `{{- define "methodSignature"}}
	{{- if not (empty ($.OpSecurity .RuntimeParams.op)) -}}
		user *{{ $.CheckPackage $.Params.Auth "http" -}},
	{{- end }}
	{{- range $param := .RuntimeParams.op.Parameters -}}
		{{ camel $param.Value.Name }}  {{ if and (not $param.Value.Required) (not (eq $param.Value.Schema.Value.Type "array")) }}*{{ end }}{{ $.GetType "" $param.Value.Name $param.Value.Schema }},
	{{- end -}}
	{{- if isNotNil .RuntimeParams.op.RequestBody}}
		{{- $type := $.GetType "" "" (index  .RuntimeParams.op.RequestBody.Value.Content "application/json").Schema}}
		{{- camel $type}} {{ $type -}}
	{{- end -}}
	) (
	{{- $response := $.GetOpHappyResponseType "http" .RuntimeParams.op}}
	{{- if notEmpty $response}} {{$response}},
	{{- end -}}
	 error)
{{- end -}}

{{- define "paramExtractionFunc" -}}
	{{- $source := .RuntimeParams.source }}
	{{- $type := .RuntimeParams.type }}
	{{- pascal $source -}}
	{{- if eq $type "[]string" -}}Strings
	{{- else }}{{pascal $type}}{{end -}}
{{- end -}}

{{- define "paramExtraction" -}}
	{{- $param := .RuntimeParams.param }}
	{{- $goType := ($.GetType "" $param.Value.Name $param.Value.Schema) }}
	{{- $required := $param.Value.Required }}
		{{- if $required }}

	{{ camel $param.Value.Name }}, err := fastutil.{{template "paramExtractionFunc" ($.WithParams "source" $param.Value.In "type" $goType )}}(ctx, "{{ $param.Value.Name }}")
	if err != nil {
		h.errorHandler(ctx, validation.New("{{ $param.Value.Name }}", err.Error()))
		return
	}
		{{- else }}
	{{ camel $param.Value.Name }} := fastutil.{{template "paramExtractionFunc" ($.WithParams "source" $param.Value.In "type" $goType )}}Optional(ctx, "{{ $param.Value.Name }}")
		{{- end }}
{{- end -}}

// Code generated by foji {{ version }}, template: {{ templateFile }}; DO NOT EDIT.

package http

import (
	"context"
	"encoding/json"

	"github.com/bir/iken/fastctx"
	"github.com/bir/iken/fastutil"
	"github.com/bir/iken/validation"
	"github.com/fasthttp/router"
	"github.com/valyala/fasthttp"
	"{{ .Params.Package }}"
)

type Service interface {
{{- range $name, $path := .API.Paths }}
	{{- range $verb, $op := $path.Operations }}
	{{ pascal $op.OperationID}}(ctx context.Context,
	{{- template "methodSignature" ($.WithParams "op" $op) }}
	{{- end }}
{{- end }}
}

type OpenAPIHandlers struct {
	service      Service
	errorHandler fastutil.ErrorHandlerFunc
	{{- range $security, $value := .API.Components.SecuritySchemes }}
	{{ camel $security }}Auth HttpAuthFunc
	{{- end }}
	{{- if .HasAuthorization }}
	authorize Authorizer
	{{- end}}
{{- range $name, $path := .API.Paths }}
	{{- range $verb, $op := $path.Operations }}
		{{- if not ($.IsSimpleAuth $op) }}
	{{ camel $op.OperationID}}AuthGroups SecurityGroups
		{{- end}}
	{{- end}}
{{- end}}
}

func RegisterHTTP(svc Service, r *router.Router, e fastutil.ErrorHandlerFunc
{{- $hasSecurity := false -}}
{{- range $security, $value := .API.Components.SecuritySchemes -}}
	, {{ camel $security }}Auth
{{- $hasSecurity = true -}}
{{- end -}}
{{- if $hasSecurity }} HttpAuthFunc {{- end -}}
{{- if .HasAuthorization -}}
	, authorize Authorizer
{{- end -}}
) *OpenAPIHandlers {
    s := OpenAPIHandlers{service: svc, errorHandler: e
{{- range $security, $value := .API.Components.SecuritySchemes -}}
	,{{ camel $security }}Auth: {{ camel $security }}Auth
{{- end -}}
	{{- if .HasAuthorization }}, authorize: authorize{{- end -}}
}

{{- range $name, $path := .API.Paths }}

	{{ range $verb, $op := $path.Operations }}
		r.{{upper $verb}}("{{$name}}", s.{{ pascal $op.OperationID}})
	{{- end }}
{{- end }}

{{- range $name, $path := .API.Paths }}
	{{ range $verb, $op := $path.Operations }}
		{{- if not ($.IsSimpleAuth $op) }}
			s.{{ camel $op.OperationID}}AuthGroups = NewSecurityGroups(
			{{- $securityList := $.OpSecurity $op }}
			{{- range $securityGroup := $securityList -}}
				SecurityGroup{}
				{{- range $security, $scopes := $securityGroup -}}
					.Add("{{camel $security}}",{{camel $security}}Auth
					{{- if not (empty $scopes) -}}
						{{- range $scopes -}}
						, "{{.}}"
						{{- end -}}
					{{- end -}}
					)
				{{- end -}}
			{{- end -}})
		{{- end}}
	{{- end}}
{{- end}}

	return &s
}

func (h *OpenAPIHandlers) doJSONWrite(ctx *fasthttp.RequestCtx, code int, obj interface{}) {
	if err := fastutil.JSONWrite(ctx, code, obj); err != nil {
		h.errorHandler(ctx, err)
	}
}

{{- range $name, $path := .API.Paths }}
	{{- range $verb, $op := $path.Operations }}

func (h *OpenAPIHandlers) {{ pascal $op.OperationID}}(ctx *fasthttp.RequestCtx) {
{{- $securityList := $.OpSecurity $op }}
	var (
{{- if not (empty $securityList)}}
		authUser *{{ $.CheckPackage $.Params.Auth "http" }}
{{- end}}
		err error
	)

	fastctx.SetOp(ctx, "{{$op.OperationID}}")

{{- if $.IsSimpleAuth $op }}

{{- $lastAuth := "" }}
	{{- range $securityGroup := $securityList }}
		{{- range $security, $scopes := $securityGroup }}
			{{- if eq $lastAuth $security }}
			{{- else }}

	authUser, err = h.{{ camel $security }}Auth(ctx)
	{{- $lastAuth = $security }}
			{{- end}}
		{{- end}}
	{{- end}}

{{- $authCt := 0 }}
	{{- range $securityGroup := $securityList }}
		{{- range $security, $scopes := $securityGroup }}
			{{- if not (empty $scopes) }}
				{{- if eq $authCt 0 }}
	if err == nil {
				{{- else }}
	if err != nil {
				{{- end }}
		err = h.authorize(authUser{{range $scopes}}, "{{.}}"{{end}})
	{{- $authCt = inc $authCt }}
			{{- end}}
		{{- end}}
	{{- end}}
{{ repeat $authCt "}\n" }}
{{- else }}
	authUser, err = doAuthorize(ctx, {{- if $.HasAuthorization }}h.authorize,{{end}} h.{{ camel $op.OperationID}}AuthGroups...)
{{- end}}
{{- if $.HasAnyAuth $op }}

	if err != nil {
		h.errorHandler(ctx, err)
		return
	}

	{{- if $.RequiresAuthUser $op }}
	if authUser == nil {
		h.errorHandler(ctx, fastutil.ErrUnauthorized)
		return
	}
	{{- end}}
{{- end}}

		{{- range $param := $op.Parameters }}
			{{- template "paramExtraction" ($.WithParams "param" $param) }}
		{{- end }}

	{{- $hasBody := isNotNil $op.RequestBody}}
	{{- if $hasBody }}

	body := {{ $.GetType "" "" (index $op.RequestBody.Value.Content "application/json").Schema }}{}
{{/*	// TODO: Set Defaults*/}}

	err = json.Unmarshal(ctx.PostBody(), &body)
	if err != nil {
		h.errorHandler(ctx, err)
		return
	}

	err = body.Validate()
	if err != nil {
		h.errorHandler(ctx, err)
		return
	}
	{{- end }}

	{{- $response := $.GetOpHappyResponseType "http" $op}}
	{{- if notEmpty $response}}

	response, err := h.service.{{ pascal $op.OperationID}}(ctx,
	{{- else}}

	err = h.service.{{ pascal $op.OperationID}}(ctx,
	{{- end}}
	{{- if not (empty $securityList) -}}
		authUser,
	{{- end -}}
	{{- range $param := $op.Parameters -}}
		{{ camel $param.Value.Name }},
	{{- end -}}
	{{- if $hasBody -}}
		body
	{{- end -}}

	)
	if err != nil {
		h.errorHandler(ctx, err)
		return
	}

{{- /*	// TODO: ? ctx.Response.Header.Set("Access-Control-Allow-Origin", "*")*/}}
{{- /*	// TODO: Code/Encoding based on response*/}}
	{{- $key := $.GetOpHappyResponseKey $op }}
	{{- if notEmpty $response }}

	h.doJSONWrite(ctx, {{$key}}, response)
	{{- else }}

	ctx.Response.SetStatusCode({{$key}})
	{{- end }}
}
	{{- end }}
{{- end }}`

var FojiSlashOpenapiSlashMainDotGoDotTplBytes = []byte(FojiSlashOpenapiSlashMainDotGoDotTpl)

const FojiSlashOpenapiSlashMainDotGoDotTpl = `package main

import (
	"fmt"
	"io"
	"io/ioutil"
	"os"
	"time"

	"github.com/bir/iken/chain"
	"github.com/bir/iken/errs"
	"github.com/bir/iken/fastutil"
	"github.com/bir/iken/notify"
	"github.com/fasthttp/router"
	"github.com/rs/zerolog"
	"github.com/rs/zerolog/log"
	"github.com/valyala/fasthttp"
"{{ .Params.Package }}"
"{{ .Params.Package }}/http"
)

func main() {
	address := "localhost:3000"

	r := router.New()
	l := setupLogging(true)

	n := notify.NewZerolog(l)
	_, _ = n.Send("startup")

	defer notify.Monitor(n)

	r.PanicHandler = fastutil.PanicHandler
    http.RegisterHTTP(test.New(), r, http.ErrorHandler
{{- range $security, $value := .File.API.Components.SecuritySchemes -}}
	, {{ $.PackageName }}.{{ pascal $security }}Auth()
{{- end -}}
)

	server := &fasthttp.Server{}
	server.NoDefaultServerHeader = true
	c := chain.New(fasthttp.CompressHandler,
		fastutil.RequestLogger(l, n, false, true, true))

	server.Handler = c.Handler(r.Handler)

	l.Info().Msgf("Serving on: http://%s", address)

	if err := server.ListenAndServe(address); err != nil {
		log.Err(err)
	}
}

func setupLogging(consoleLog bool) zerolog.Logger {
	zerolog.DurationFieldInteger = true
	zerolog.DurationFieldUnit = time.Millisecond
	zerolog.ErrorStackMarshaler = errs.MarshalStack

	var out io.Writer = os.Stdout

	if consoleLog {
		out = zerolog.NewConsoleWriter()
	}

	return log.Output(out)
}
`

var FojiSlashOpenapiSlashModelDotGoDotTplBytes = []byte(FojiSlashOpenapiSlashModelDotGoDotTpl)

const FojiSlashOpenapiSlashModelDotGoDotTpl = `{{- define "propertyDeclaration"}}
    {{- $key := .RuntimeParams.key }}
    {{- $schema := .RuntimeParams.schema }}
    {{- $typeName := .RuntimeParams.typeName }}
    {{- if not (empty $schema.Value.Description) }}
    // {{ $schema.Value.Description }}
    {{- end }}
    {{- if $.IsDefaultEnum  $key $schema }}
    {{ pascal $key }}  {{print $typeName (pascal $key) "Enum"}} ` + "`" + `json:"{{$key}},omitempty"` + "`" + `
    {{- else }}
    {{ pascal $key }} {{ $.GetType .PackageName $key $schema }} ` + "`" + `json:"{{$key}},omitempty"` + "`" + `
    {{- end }}
{{- end -}}

// Code generated by foji {{ version }}, template: {{ templateFile }}; DO NOT EDIT.

package {{ .PackageName }}

import (
{{- range .Imports }}
    "{{ . }}"
{{- end }}
    "github.com/bir/iken/validation"
)
{{ range $key, $schema := .File.API.Components.Schemas }}
{{- if isNil (index $schema.Value.Extensions "x-go-type" ) }}
{{- $typeName := pascal $key }}
//  {{ $typeName }}
{{- if not (empty .Value.Description) }}
//  {{ $schema.Value.Description }}
{{- end}}
//
// OpenAPI Component: {{ $key }}
type {{ pascal $key }} struct {
{{- range $key, $schema := .Value.Properties }}
    {{- template "propertyDeclaration" ($.WithParams "key" $key "schema" $schema "typeName" $typeName)}}
{{- end }}
{{- range .Value.AllOf }}
    {{- if notEmpty .Ref }}
        {{ $.GetTypeName $.PackageName  . }}
    {{- else }}
        {{- range $key, $schema := .Value.Properties }}
            {{- template "propertyDeclaration" ($.WithParams "key" $key "schema" $schema "typeName" $typeName)}}
        {{- end }}
    {{- end }}
{{- end }}

}
{{- range $key, $schema := .Value.Properties }}
    {{- if notEmpty $schema.Value.Pattern }}

var {{ camel $typeName }}{{ pascal $key }}Pattern = regexp.MustCompile(` + "`" + `{{ $schema.Value.Pattern }}` + "`" + `)
    {{- end}}
{{- end }}

{{- range $key, $schema := .Value.Properties }}
    {{- if not (empty $schema.Value.Enum) }}
    {{- $enumType := print $typeName (pascal $key) "Enum" }}

type {{ $enumType }} int32

const (
    Unknown{{ $enumType }} {{ $enumType }} = iota
    {{- range $i, $value := $schema.Value.Enum }}
    {{ $enumType }}{{ pascal (goToken $value) }}
    {{- end }}
)

func New{{ $enumType }}(name string) {{ $enumType }} {
    switch name {
    {{- range $schema.Value.Enum  }}
        case "{{ . }}":
        return {{ $enumType }}{{ pascal (goToken .) }}
    {{- end }}
    }

    return {{ $enumType }}(0)
}


var  {{ $enumType }}String = map[{{ $enumType }}]string{
    {{- range $schema.Value.Enum }}
        {{ $enumType }}{{ pascal (goToken .) }}: "{{ . }}",
    {{- end }}
}

func (e {{ $enumType }}) String() string {
    return {{ $enumType }}String[e]
}

func (e *{{ $enumType }}) UnmarshalJSON(input []byte) (err error) {
	var i int32

	err = json.Unmarshal(input, &i)
	if err == nil {
		*e = {{ $enumType }}(i)
		return nil
	}

	var s string

	err = json.Unmarshal(input, &s)
	if err != nil {
		return err
	}

	*e = New{{ $enumType }}(s)

	return nil
}

func (e *{{ $enumType }}) MarshalJSON() (result []byte, err error) {
    return json.Marshal(e.String())
}
    {{- end}}
{{- end }}

func (p {{ pascal $key }}) Validate() error {
    {{- if $.HasValidation . }}
    var err validation.Errors
{{- range $key, $schema := .Value.Properties }}
    {{- if in $schema.Value.Type "number" "integer" }}
        {{- $fieldType := $.GetType $.PackageName $key $schema }}
        {{- if isNotNil $schema.Value.Min }}

    if p.{{ pascal $key }} <{{ if $schema.Value.ExclusiveMin }}={{end}} {{ $schema.Value.Min }} {
        _ = err.Add("{{$key}}", "must be >{{ if not $schema.Value.ExclusiveMin }}={{end}} {{ $schema.Value.Min }}")
    }
        {{- end }}
        {{- if isNotNil $schema.Value.Max }}

    if p.{{ pascal $key }} >{{ if $schema.Value.ExclusiveMax }}={{end}} {{ $schema.Value.Max }} {
        _ = err.Add("{{$key}}", "must be <{{ if not $schema.Value.ExclusiveMax }}={{end}} {{ $schema.Value.Max }}")
    }
        {{- end }}
        {{- if isNotNil $schema.Value.MultipleOf }}
            {{- if eq $schema.Value.Type "integer" }}

    if p.{{ pascal $key }} % {{ $schema.Value.MultipleOf }} != 0 {
        _ = err.Add("{{$key}}", "must be multiple of {{ $schema.Value.MultipleOf }}")
    }
            {{- else }}
    if math.Mod({{ if not (eq $fieldType "float64") }}float64({{ end }}p.{{ pascal $key }}{{ if not (eq $fieldType "float64") }}){{end}}, {{ $schema.Value.MultipleOf }}) != 0 {
        _ = err.Add("{{$key}}", "must be multiple of {{ $schema.Value.MultipleOf }}")
    }
            {{- end }}
        {{- end }}
    {{- else if eq $schema.Value.Type "string" }}
        {{- $fieldType := $.GetType $.PackageName $key $schema }}
        {{- if gt $schema.Value.MinLength 0 }}

    if len(p.{{ pascal $key }}) < {{ $schema.Value.MinLength }} {
        _ = err.Add("{{$key}}", "length must be >= {{ $schema.Value.MinLength }}")
    }
        {{- end }}
        {{- if isNotNil $schema.Value.MaxLength }}

    if len(p.{{ pascal $key }}) > {{ $schema.Value.MaxLength }} {
        _ = err.Add("{{$key}}", "length must be <= {{ $schema.Value.MaxLength }}")
    }
        {{- end }}
        {{- if notEmpty $schema.Value.Pattern }}

    if !{{ camel $typeName }}{{ pascal $key }}Pattern.MatchString( p.{{ pascal $key }})  {
        _ = err.Add("{{$key}}", "must match {{ $schema.Value.Pattern }}")
    }
        {{- end }}
    {{- else if eq $schema.Value.Type "array" }}
        {{- if gt $schema.Value.MinItems 0 }}

    if len(p.{{ pascal $key }}) < {{ $schema.Value.MinItems }} {
        _ = err.Add("{{$key}}", "length must be >= {{ $schema.Value.MinItems }}")
    }
        {{- end }}
        {{- if isNotNil $schema.Value.MaxItems }}

    if len(p.{{ pascal $key }}) > {{ $schema.Value.MaxItems }} {
        _ = err.Add("{{$key}}", "length must be <= {{ $schema.Value.MaxItems }}")
    }
        {{- end }}
    {{- end }}
{{- end }}

    return err.GetErr()
{{- else }}
    return nil
{{- end }}
}
{{ end }}
{{- end}}

`

var FojiSlashOpenapiSlashServiceDotGoDotTplBytes = []byte(FojiSlashOpenapiSlashServiceDotGoDotTpl)

const FojiSlashOpenapiSlashServiceDotGoDotTpl = `{{- define "methodSignature"}}
	{{- if not (empty ($.OpSecurity .RuntimeParams.op)) -}}
		user *{{ $.CheckPackage $.Params.Auth $.Params.Package -}},
	{{- end }}
	{{- range $param := .RuntimeParams.op.Parameters -}}
		{{ camel $param.Value.Name }}  {{ if and (not $param.Value.Required) (not (eq $param.Value.Schema.Value.Type "array")) }}*{{ end }}{{ $.GetType "" $param.Value.Name $param.Value.Schema }},
	{{- end -}}
	{{- if isNotNil .RuntimeParams.op.RequestBody}}
		{{- $type := $.GetType .PackageName "" (index  .RuntimeParams.op.RequestBody.Value.Content "application/json").Schema}}
		{{- camel $type}} {{ $type -}}
	{{- end -}}
	) (
	{{- $response := $.GetOpHappyResponseType .PackageName .RuntimeParams.op}}
	{{- if notEmpty $response}} {{$response}},
	{{- end -}}
	error)
{{- end -}}

package {{ .PackageName }}

import (
	"time"

	"github.com/bir/iken/errs"
	"github.com/bir/iken/validation"
	"github.com/valyala/fasthttp"
)

type ServiceError string

func (e ServiceError) Error() string {
	return string(e)
}

const ErrNotImplemented = ServiceError("not implemented")

// New creates a new service instance.
func New() *Service {
	return &Service{}
}

// Service implements all business logic for {{ .PackageName }}.
type Service struct {
}

{{- range $name, $path := .File.API.Paths }}
	{{- range $verb, $op := $path.Operations }}

{{ goDoc (print (pascal $op.OperationID) " " $op.Description) }}.
func (s *Service) {{ pascal $op.OperationID}}(ctx context.Context,
	{{- template "methodSignature" ($.WithParams "op" $op) }}{
	{{- $response := $.GetOpHappyResponseType $.PackageName $op}}
	{{- if notEmpty $response }}
	return nil, ErrNotImplemented
	{{- else }}
	return ErrNotImplemented
	{{- end }}
}
	{{- end }}
{{- end }}`

var FojiSlashOpenapiSlashStubDotYamlDotTplBytes = []byte(FojiSlashOpenapiSlashStubDotYamlDotTpl)

const FojiSlashOpenapiSlashStubDotYamlDotTpl = `{{ .NotNeededIf (empty .Params.Name) "params.Name not set" -}}
openapi: "3.0.0"
info:
  title: {{case .Params.Name}}
  version: 0.1.0
paths:
{{- range .Resources }}
  {{- $resource := . }}
  /{{ camel .Name }}:
    get:
      operationId: list{{ pascal .Name }}
      summary: List {{ pascal .Name }}
      tags:
        - {{ case .Name }}
      parameters:
        - $ref: '#/components/parameters/offset'
        - $ref: '#/components/parameters/limit'
      responses:
        '200':
          description: |-
            200 response
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/{{ case (pluralUniqueName .Name) }}'
        default:
          description: unexpected error
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/Error"
{{- if not .Table.ReadOnly }}
    post:
      operationId: create{{ pascal .Name }}
      summary: Create {{ pascal .Name }}
      tags:
        - {{ case .Name }}
      responses:
        '201':
          description: |-
            200 response
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/{{ pascal .Name }}'
{{end -}}
{{if .PK -}}
{{with .PK }}
  /{{ camel $resource.Name }}/{ {{- camel .Name -}} }:
    parameters:
      - name: {{ camel .Name }}
        in: path
        description: {{ camel .Name }} of {{ pascal $resource.Name }}
        required: true
        schema:
          type: {{ .Type }}
{{- with .Format }}
          format: {{ . }}
{{end -}}
{{end }}
    get:
      description: Get {{ pascal .Name }}
      operationId: get{{ pascal .Name }}
      summary: Get {{ pascal .Name }}
      tags:
        - {{ case .Name }}
      responses:
        '200':
          description: successful response
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/{{ pascal .Name }}'
        default:
          description: unexpected error
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Error'
{{- if not .Table.ReadOnly }}
    post:
      description: updates a {{ pascal .Name }}
      operationId: update{{ pascal .Name }}
      summary: Update {{ pascal .Name }}
      tags:
        - {{ case .Name }}
      responses:
        '200':
          description: {{ pascal .Name }} updated
        default:
          description: unexpected error
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Error'
    delete:
      description: deletes a {{ pascal .Name }}
      operationId: delete{{ pascal .Name }}
      summary: Delete {{ pascal .Name }}
      tags:
        - {{ case .Name }}
      responses:
        '204':
          description: {{ pascal .Name }} deleted
        default:
          description: unexpected error
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Error'
{{end -}}
{{end -}}
{{end -}}
components:
  responses:
    BadRequest:
      description: The specified resource was not found
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/Error'
    NotFound:
      description: The specified resource was not found
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/Error'
    Unauthorized:
      description: Unauthorized
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/Error'
  parameters:
    limit:
      name: limit
      in: query
      description: How many items to return for each page
      required: false
      schema:
        type: integer
        format: int32
        default: 100
        maximum: 255
        minimum: 10
    offset:
      name: offset
      in: query
      description: Offset of page to return
      required: false
      schema:
        type: integer
        format: int32
        default: 0
        minimum: 0
  schemas:
{{- range .Resources }}
    {{pascal .Name}}:
      type: object
      properties:
{{- range .Properties }}
        {{ camel .Name }}:
          type: {{ .Type }}
{{- with .Format }}
          format: {{ . }}
{{- end -}}
{{end}}
    {{case (pluralUniqueName .Name) }}:
      type: object
      properties:
        page:
          type: integer
        pageSize:
          type: integer
        totalRecordCount:
          type: integer
        list:
            type: array
            items:
              $ref: '#/components/schemas/{{ pascal .Name }}'
{{- end}}
    Error:
      type: object
      required:
        - code
        - message
      properties:
        code:
          type: integer
          format: int32
        message:
          type: string`

var FojiSlashPgxSlashDbDotGoDotTplBytes = []byte(FojiSlashPgxSlashDbDotGoDotTpl)

const FojiSlashPgxSlashDbDotGoDotTpl = `// Code generated by foji {{ version }}, template: {{ templateFile }}; DO NOT EDIT.

package pg

import (
	"context"
	"database/sql"
	"errors"

	"github.com/jackc/pgconn"
	"github.com/jackc/pgx/v4"
)

// DB is the common interface for database operations.
type DB interface {
	Exec(context.Context, string, ...interface{}) (pgconn.CommandTag, error)
	Query(context.Context, string, ...interface{}) (pgx.Rows, error)
	QueryRow(context.Context, string, ...interface{}) pgx.Row
}

func IsErrNoRows(err error) bool {
	return errors.Is(err, pgx.ErrNoRows) || errors.Is(err, sql.ErrNoRows)
}

type Repo struct {
	db DB
}

func New(db DB) Repo {
	return Repo{db: db}
}`

var FojiSlashPgxSlashModelDotGoDotTplBytes = []byte(FojiSlashPgxSlashModelDotGoDotTpl)

const FojiSlashPgxSlashModelDotGoDotTpl = `// Code generated by foji {{ version }}, template: {{ templateFile }}; DO NOT EDIT.
{{- $table := .Table.Name}}
{{- $goName := case .Table.Name -}}
{{- $colNames := .Table.Columns.ByOrdinal.Names }}
{{- $pkNames := cases .Table.PrimaryKeys.ByOrdinal.Names }}

package {{ $.PackageName }}

import (
	"fmt"

{{- range .Imports }}
	"{{ . }}"
{{- end }}
)

// {{$goName}} represents a record from '{{$table}}'.
type {{$goName}} struct {
{{- range .Table.Columns.ByOrdinal }}
	{{ case .Name }} {{ $.GetType . $.PackageName }}  ` + "`" + `json:"{{ .Name }},omitempty"` + "`" + ` // {{ .Type }} {{ if .Nullable }}NULL{{end}}
{{- end }}
}

func (r {{$goName}}) String() string {
	return fmt.Sprintf( "{{$goName}}{
		{{- csv ($pkNames.Sprintf "%s:%%v" ) }}}",
		{{- csv ($pkNames.Sprintf "r.%s" ) }})
}

// Field values for every column in {{.Table.Name}}.  These are used for custom where clause queries
var (
{{- range .Table.Columns.ByOrdinal }}
	{{$goName}}{{case .Name}} {{ title (replaceEach ( $.GetType . $.PackageName) "" "." "*" "{" "}" ) }}Field = "{{ .Name }}"
{{- end}}
)

`

var FojiSlashPgxSlashTableDotGoDotTplBytes = []byte(FojiSlashPgxSlashTableDotGoDotTpl)

const FojiSlashPgxSlashTableDotGoDotTpl = `// Code generated by foji {{ version }}, template: {{ templateFile }}; DO NOT EDIT.
{{- $pkgName := "pg" }}
{{- $table := .Table.Name}}
{{- $schema := .Table.Schema.Name}}
{{- $goName := case $table }}
{{- $hasSoftDeletes := .Table.Columns.Names.Contains "deleted_at"}}
{{- $mutableCols := (.Table.Columns.Filter .Table.PrimaryKeys.Paths).ByOrdinal.Names }}
{{- $mutableFields := (cases $mutableCols).Sprintf "row.%s"}}
{{- $scanFields := (cases .Table.Columns.ByOrdinal.Names).Sprintf "&row.%s"}}
{{- $selectFields := csv .Table.Columns.ByOrdinal.Names}}
{{- $PKs := cases .Table.PrimaryKeys.ByOrdinal.Names }}
{{- $PKFields := csv ($PKs.Sprintf "row.%s")}}
{{- $PKScanFields := csv ($PKs.Sprintf "&row.%s")}}

package {{ $pkgName }}

import (
	"context"

	"github.com/jackc/pgx/v4"
	"github.com/pkg/errors"

	"{{.Params.Package}}"
{{- range .Imports }}
	"{{ . }}"
{{- end }}
)

const querySelect{{$goName}} = ` + "`" + `SELECT
	{{ $selectFields }}
FROM {{$schema}}.{{$table}} ` + "`" + `

func scan{{$goName}}(rr pgx.Rows) ([]*{{$.PackageName}}.{{$goName}}, error) {
	var result []*{{$.PackageName}}.{{$goName}}
	for rr.Next() {
		row := {{$.PackageName}}.{{$goName}}{}
		err := rr.Scan({{ csv $scanFields }})
		if err != nil {
			return nil, errors.Wrap(err, "{{$goName}}.scan") // notest
		}
		result = append(result, &row)
	}
	return result, nil
}

func scanOne{{$goName}}(rr pgx.Row) (*{{$.PackageName}}.{{$goName}}, error) {
	row := {{$.PackageName}}.{{$goName}}{}
	err := rr.Scan({{ csv $scanFields }})
	if err != nil {
		return nil, errors.Wrap(err, "{{$goName}}.scanOne")
	}
	return &row, nil
}

// All retrieves all rows from '{{$table}}' as a slice of {{$goName}}.
func (r Repo) All{{$goName}}(ctx context.Context) ([]*{{$.PackageName}}.{{$goName}}, error) {
	query :=  querySelect{{$goName }}
{{- if $hasSoftDeletes -}}
	+ ` + "`" + ` WHERE deleted_at is NULL ` + "`" + `
{{- end}}
	q, err := r.db.Query(ctx,query)
	if err != nil {
		return nil, errors.Wrap(err, "{{$goName}}.All")
	}
	return scan{{$goName}}(q)
}

// Count gets size of '{{$table}}'.
func (r Repo) Count{{$goName}}(ctx context.Context, where {{$.PackageName}}.WhereClause) (int, error) {
	idx := 1
	query := ` + "`" + `SELECT
		count(*) as count
		FROM {{$schema}}.{{$table}}
		WHERE ` + "`" + ` + where.String(&idx)
		
	count := 0
	return count, r.db.QueryRow(ctx, query, where.Values()...).Scan(&count)
}

// Select retrieves rows from '{{$table}}' as a slice of {{$goName}}.
func (r Repo) Select{{$goName}}(ctx context.Context, where {{$.PackageName}}.WhereClause) ([]*{{$.PackageName}}.{{$goName}}, error) {
	idx := 1
	query := querySelect{{$goName}} + " WHERE " + where.String(&idx)
{{- if $hasSoftDeletes -}}
	+ ` + "`" + ` AND deleted_at is NULL ` + "`" + `
{{- end}}

	q, err := r.db.Query(ctx, query, where.Values()...)
	if err != nil {
		return nil, errors.Wrap(err, "{{$goName}}.Select")
	}
	return scan{{$goName}}(q)
}

// SelectOrder retrieves rows from '{{$table}}' as a slice of {{$goName}} in a particular order.
func (r Repo) SelectOrder{{$goName}}(ctx context.Context, where {{$.PackageName}}.WhereClause, orderBy {{$.PackageName}}.OrderByClause) ([]*{{$.PackageName}}.{{$goName}}, error) {
	idx := 1
	query := querySelect{{$goName}} + " WHERE " + where.String(&idx)
{{- if $hasSoftDeletes -}}
	+ ` + "`" + ` AND deleted_at is NULL ` + "`" + `
{{- end}} + " " + orderBy.String()

	q, err := r.db.Query(ctx, query, where.Values()...)
	if err != nil {
		return nil, errors.Wrap(err, "{{$goName}}.SelectOrder")
	}
	return scan{{$goName}}(q)
}

// First retrieve one row from '{{$table}}' when sorted by orderBy.
func (r Repo) First{{$goName}}(ctx context.Context, where {{$.PackageName}}.WhereClause, orderBy {{$.PackageName}}.OrderByClause) (*{{$.PackageName}}.{{$goName}}, error) {
	idx := 1
	query := querySelect{{$goName}} + " WHERE " + where.String(&idx)
{{- if $hasSoftDeletes -}}
	+ ` + "`" + ` AND deleted_at is NULL ` + "`" + `
{{- end}} + " " + orderBy.String() + " LIMIT 1"

	q := r.db.QueryRow(ctx, query, where.Values()...)
	return scanOne{{$goName}}(q)
}

{{- /* Takes the number of values to produce and produces a list of postgres
placeholders of the form $1, $2, etc */}}
{{- define "values" -}}
	{{$nums := numbers 1 . -}}
	{{$indices := $nums.Sprintf "$%s" -}}
	{{csv $indices -}}
{{end}}

// Insert inserts the row into the database.
func (r Repo) Insert{{$goName}}(ctx context.Context, row *{{$.PackageName}}.{{$goName}}) error {
const query = ` + "`" + `INSERT INTO {{$schema}}.{{$table}}
{{- if gt (len $mutableCols) 0}}
	({{ csv $mutableCols }})
	VALUES
	({{template "values" (len $mutableCols) }})
{{- else}}
	DEFAULT VALUES
{{- end}}
	RETURNING
		{{csv .Table.PrimaryKeys.Names.Sort }}` + "`" + `
	q := r.db.QueryRow(ctx, query,{{- csv $mutableFields }})
	return q.Scan({{$PKScanFields}})
}
{{if gt (len $mutableCols) 0}}
// Update the Row in the database.
func (r Repo) Update{{$goName}}(ctx context.Context, row *{{$.PackageName}}.{{$goName}}) error {
	query := ` + "`" + `UPDATE {{$schema}}.{{$table}}
	SET
		({{csv $mutableCols }}) =
		({{ template "values" (len $mutableCols) }})
	WHERE
	{{$last := sum (len .Table.PrimaryKeys) (len $mutableCols)}}
	{{- $first := inc (len $mutableCols)}}
	{{- range $x, $name := .Table.PrimaryKeys.Names.Sort -}}
		{{$name}} = ${{sum $first $x}}{{if lt (sum $x $first) $last}} AND {{end}}
	{{- end}}` + "`" + `

	_, err := r.db.Exec(ctx, query, {{csv $mutableFields }}, {{$PKFields}})
	return errors.Wrap(err, "{{$goName}}.update")
	}
{{end}}
// Set sets a single column on an existing row in the database.
func (r Repo) Set{{$goName}}(ctx context.Context, set {{$.PackageName}}.Where, where {{$.PackageName}}.WhereClause) (int64, error) {
	idx := 2
	query := ` + "`" + `UPDATE {{$schema}}.{{$table}} SET ` + "`" + ` +
		set.Field + " = $1 " +
		` + "`" + ` WHERE ` + "`" + ` +
		where.String(&idx)

	res, err := r.db.Exec(ctx, query, append([]interface{}{ set.Value }, where.Values()...)...)
	if err != nil {
		return 0, errors.Wrap(err, "{{$goName}}.set")
	}
	return res.RowsAffected(), nil
}
{{- if .Table.HasPrimaryKey }}
{{- if $hasSoftDeletes}}
// Delete{{$goName}} soft deletes the Row from the database. Returns the number of items soft deleted.
{{else}}
// Delete{{$goName}} deletes the Row from the database. Returns the number of items deleted.
{{end}}
func (r Repo) Delete{{$goName}}( ctx context.Context, {{ $.Parameterize .Table.PrimaryKeys "%s %s" $pkgName }}) (int64, error) {
	{{- if $hasSoftDeletes}}
	const query = ` + "`" + `UPDATE {{$schema}}.{{$table}}
		SET deleted_at = now()
		WHERE
		{{ range $x, $name := .Table.PrimaryKeys.Names.Sort -}}
			{{$name}} = ${{inc $x}}{{if lt $x (sum (len $.Table.PrimaryKeys) -1)}} AND {{end}}
		{{- end}} AND deleted_at is NULL
		` + "`" + `
	{{- else }}
	const query = ` + "`" + `DELETE FROM {{$schema}}.{{$table}} WHERE
		{{ range $x, $name := .Table.PrimaryKeys.Names.Sort -}}
			{{$name}} = ${{inc $x}}{{if lt $x (sum (len $.Table.PrimaryKeys) -1)}} AND {{end}}
		{{- end}}` + "`" + `{{- end}}
	res, err := r.db.Exec(ctx, query,
	{{- csv .Table.PrimaryKeys.Names.Sort.Camel  -}}
	)
	if err != nil {
		return 0, errors.Wrap(err, "{{$goName}}.Delete")
	}
	return res.RowsAffected(), nil
}
{{- if $hasSoftDeletes}}
// DeletePermanent{{$goName}} deletes the Row from the database. This bypasses the soft delete mechanism.
// Returns the number of items deleted.
func (r Repo) DeletePermanent{{$goName}}( ctx context.Context, {{ $.Parameterize .Table.PrimaryKeys "%s %s" $pkgName }}) (int64, error) {
	const query = ` + "`" + `DELETE FROM {{$schema}}.{{$table}} WHERE
		{{ range $x, $name := .Table.PrimaryKeys.Names.Sort -}}
			{{$name}} = ${{inc $x}}{{if lt $x (sum (len $.Table.PrimaryKeys) -1)}} AND {{end}}
		{{- end}}` + "`" + `
	res, err := r.db.Exec(ctx, query,
	{{- csv .Table.PrimaryKeys.Names.Sort.Camel  -}}
	)
	if err != nil {
		return 0, errors.Wrap(err, "{{$goName}}.DeletePermanent")
	}
	return res.RowsAffected(), nil
}
{{end}}
{{end}}
// DeleteWhere{{$goName}} deletes Rows from the database and returns the number of rows deleted.
func (r Repo) DeleteWhere{{$goName}}(ctx context.Context, where {{$.PackageName}}.WhereClause) (int64, error) {
	idx := 1
{{ if $hasSoftDeletes}}
	query := ` + "`" + `UPDATE {{$schema}}.{{$table}}
		SET deleted_at = now()
		WHERE ` + "`" + ` + where.String(&idx) + ` + "`" + ` AND deleted_at is NULL` + "`" + `
{{ else }}
	query := ` + "`" + `DELETE FROM {{$schema}}.{{$table}}
		WHERE ` + "`" + ` + where.String(&idx)
{{ end }}
	res, err := r.db.Exec(ctx, query, where.Values()...)
	if err != nil {
		return 0, errors.Wrap(err, "{{$goName}}.DeleteWhere")
	}
	return res.RowsAffected(), nil
}
{{ if $hasSoftDeletes}}
// UndeleteWhere{{$goName}} undeletes the Row from the database.
func (r Repo) Undelete{{$goName}}(ctx context.Context, {{ $.Parameterize .Table.PrimaryKeys "%s %s" $pkgName }}) (int64, error) {
	query := ` + "`" + `UPDATE {{$schema}}.{{$table}}
	SET deleted_at = NULL
	WHERE
{{- range $x, $name := .Table.PrimaryKeys.Names.Sort }}
	{{$name}} = ${{inc $x}}{{if lt $x (sum (len $.Table.PrimaryKeys) -1)}} AND {{end}}
{{- end}} AND deleted_at is not NULL` + "`" + `

	res, err := r.db.Exec(ctx, query, {{ csv .Table.PrimaryKeys.Names.Sort.Camel  -}})
	if err != nil {
		return 0, errors.Wrap(err, "{{$goName}}.Undelete")
	}
	return res.RowsAffected(), nil
}

// DeleteWherePermanent{{$goName}} deletes the Row from the database. This bypasses the soft delete mechanism.
// Returns the number of items deleted.
func (r Repo) DeleteWherePermanent{{$goName}}(ctx context.Context, where {{$.PackageName}}.WhereClause) (int64, error) {
	idx := 1
	query := ` + "`" + `DELETE FROM {{$schema}}.{{$table}}
		WHERE ` + "`" + ` + where.String(&idx)

	res, err := r.db.Exec(ctx, query,  where.Values()...)
	if err != nil {
		return 0, errors.Wrap(err, "{{$goName}}.DeleteWherePermanent")
	}
	return res.RowsAffected(), nil
}

// UndeleteWhere{{$goName}} undeletes the Row from the database.
func (r Repo) UndeleteWhere{{$goName}}(ctx context.Context, where {{$.PackageName}}.WhereClause) (int64, error) {
	idx := 1
	query := ` + "`" + `UPDATE {{$schema}}.{{$table}}
		SET deleted_at = null
		WHERE ` + "`" + ` + where.String(&idx) + ` + "`" + ` AND deleted_at is NOT NULL` + "`" + `

	res, err := r.db.Exec(ctx, query, where.Values()...)
	if err != nil {
		return 0, errors.Wrap(err, "{{$goName}}.UndeleteWhere")
	}
	return res.RowsAffected(), nil
}

{{ end -}}

{{ range .Table.Indexes -}}
	{{- $FuncName := print $goName "By" ((cases .Columns.Names).Join "") -}}
	{{- if $.Table.PrimaryKeys.Names.ContainsAll .Columns.Names -}}
		{{- $FuncName = print "Get" $goName -}}
	{{- end -}}
// {{$FuncName}} retrieves a row from '{{$.Table.Schema.Name}}.{{$.Table.Name}}'.
//
// Generated from index '{{.Name}}'.
func (r Repo) {{ $FuncName }}(ctx context.Context, {{ $.Parameterize .Columns "%s %s" $pkgName }}) ({{ if not .IsUnique }}[]{{ end }}*{{$.PackageName}}.{{$goName}}, error) {
	query := querySelect{{$goName}} + ` + "`" + ` WHERE {{csv .Columns.Names.Sort }} = {{template "values" (len .Columns)}}
{{- if $hasSoftDeletes }} AND deleted_at is NULL{{ end}}` + "`" + `

{{- if .IsUnique }}
	q := r.db.QueryRow(ctx, query, {{ csv (.Columns.Names.Sort.Camel) }})
{{- else }}
	q, err := r.db.Query(ctx, query, {{ csv (.Columns.Names.Sort.Camel) }})
	if err != nil {
		return nil, errors.Wrap(err, "{{$goName}}.{{ $FuncName }}")
	}
{{- end }}

{{- if .IsUnique }}
	return scanOne{{$goName}}(q)
{{- else }}
	return scan{{$goName}}(q)
{{- end }}
}

{{ end }}`

var FojiDotYamlBytes = []byte(FojiDotYaml)

const FojiDotYaml = `formats:
  go:
    case: pascal
    post:
      - [ "goimports", "-w", "$FILE" ]
    maps:
      type:
        "_name": "[]string"
        bool: bool
        boolean: bool
        double: float64
        int2: int16
        int32: int32
        int4: int32
        int8: int64
        integer: int32
        integer,int64: int64
        jsonb: interface{}
        name: string
        number: float32
        number,double: float64
        number,float: float32
        number,int32: int32
        number,int64: int64
        object: interface{}
        oid: int64
        string: string
        string,date-time: time.Time
        string,date: time.Time
        string,ipv4: net.IP
        string,ipv6: net.IP
        string,uri: net/url.URL
        string,uuid: github.com/google/uuid.UUID
        text: "*string"
        timestamptz: time.Time
        varchar: string
  openapi:
    case: pascal
    maps:
      type:
        name: string
        text: string
        int2: integer,int32
        int4: integer,int64
        varchar: string
        timestamptz: string,date-time
        jsonb: object
files:
  sql:
    files:
      - "*/*/*.sql"
    filter:
      - "^db*"
  embed:
    files:
      - "embed/*"
    filter:
      - ".*\\.go"
  api:
    files:
      - "swagger.yaml"
processes:
  repo:
    processes: [ sqlRepo, dbRepo ]
  embed:
    format: go
    resources: [ embed ]
    params:
      PackageName: embed
    EmbedAll:
      embed/embeds_gen.go: foji/embed.go.tpl
  dbList:
    format: console
    case: unchanged
    DbAll:
      stdout: foji/dbList.console.tpl
  sqlRepo:
    format: go
    resources: [ sql ]
    params:
      Package: pg
    SQLFile:
      '{{ fileWithExt .File.Source "_gen.go" }}': foji/sqlRepo.go.tpl
  dbRepo:
    format: go
    DbAll:
      '!pg/repo_gen.go': foji/pgx/db.go.tpl
      fields_gen.go: foji/fields.go.tpl
    DbTable:
      'pg/{{lower .Table.Name}}_gen.go': foji/pgx/table.go.tpl
      '{{lower .Table.Name}}_gen.go': foji/pgx/model.go.tpl
    DbEnum:
      '{{lower .Schema.Name}}/enum/{{lower .Enum.Name}}.go': foji/pgx/enum.go.tpl
  openAPIStub:
    format: openapi
    DbAll:
      '!swagger.yaml': foji/openapi/stub.yaml.tpl
  openAPI:
    format: go
    resources: [ api ]
    OpenAPIFile:
      'http/auth_gen.go': foji/openapi/auth.go.tpl
      'models_gen.go': foji/openapi/model.go.tpl
      '!service.go': foji/openapi/service.go.tpl
      'http/handler_gen.go': foji/openapi/handler.go.tpl
      '!http/error.go': foji/openapi/error.go.tpl
      '!cmd/serve/main.go': foji/openapi/main.go.tpl
  openAPIByTag:
    format: go
    resources: [ api ]
    OpenAPIFile:
      '{{lower .}}/models_gen.go': foji/openapi/model.go.tpl
      '{{lower .}}/http/auth_gen.go': foji/openapi/auth.go.tpl
      '{{lower .}}/http/handler_gen.go': foji/openapi/handler.go.tpl
      '!{{lower .}}/http/error.go': foji/openapi/error.go.tpl
      '!{{lower .}}/service.go': foji/openapi/service.go.tpl
      '!{{lower .}}/cmd/serve/main.go': foji/openapi/main.go.tpl
  openAPIDocs:
    format: go
    resources: [ api ]
    params:
      Package: doc
      RedocOptions: hide-download-button=true hide-loading=true
    EmbedAll:
      doc/embed_gen.go: foji/embed.go.tpl
      '!doc/handler.go': foji/openapi/docs.go.tpl
`

var InitDotYamlBytes = []byte(InitDotYaml)

const InitDotYaml = `db:
  connection: "host=localhost dbname=my_project sslmode=disable"
  filter:
    - "*.schema_migrations"
sql:
  files:
    - "*/*.sql"
    - "*/*/*.sql"
    - "*/*/*/*.sql"
  filter:
    - "db/migrations/.*"
embed:
  files:
    - "embed/*"
    - "embed/*/*"
  filter:
    - "*.go"
`
