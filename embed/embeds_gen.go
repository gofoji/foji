// Code generated by foji 0.1.3, template: foji/embed.go.tpl; DO NOT EDIT.

package embed

import "os"

func List() []string {
	return []string{
		"foji/dbList.console.tpl",
		"foji/embed.go.tpl",
		"foji/enum.go.tpl",
		"foji/fields.go.tpl",
		"foji/sqlRepo.go.tpl",
		"foji/openapi/auth.go.tpl",
		"foji/openapi/docs.go.tpl",
		"foji/openapi/handler.go.tpl",
		"foji/openapi/main.go.tpl",
		"foji/openapi/model.go.tpl",
		"foji/openapi/service.go.tpl",
		"foji/openapi/stub.yaml.tpl",
		"foji/pgx/db.go.tpl",
		"foji/pgx/model.go.tpl",
		"foji/pgx/table.go.tpl",
		"foji.yaml",
		"init.yaml",
	}
}

func Get(filename string) ([]byte, error) {
	switch filename {
	case "foji/dbList.console.tpl":
		return FojiSlashDbListDotConsoleDotTplBytes, nil
	case "foji/embed.go.tpl":
		return FojiSlashEmbedDotGoDotTplBytes, nil
	case "foji/enum.go.tpl":
		return FojiSlashEnumDotGoDotTplBytes, nil
	case "foji/fields.go.tpl":
		return FojiSlashFieldsDotGoDotTplBytes, nil
	case "foji/sqlRepo.go.tpl":
		return FojiSlashSqlRepoDotGoDotTplBytes, nil
	case "foji/openapi/auth.go.tpl":
		return FojiSlashOpenapiSlashAuthDotGoDotTplBytes, nil
	case "foji/openapi/docs.go.tpl":
		return FojiSlashOpenapiSlashDocsDotGoDotTplBytes, nil
	case "foji/openapi/handler.go.tpl":
		return FojiSlashOpenapiSlashHandlerDotGoDotTplBytes, nil
	case "foji/openapi/main.go.tpl":
		return FojiSlashOpenapiSlashMainDotGoDotTplBytes, nil
	case "foji/openapi/model.go.tpl":
		return FojiSlashOpenapiSlashModelDotGoDotTplBytes, nil
	case "foji/openapi/service.go.tpl":
		return FojiSlashOpenapiSlashServiceDotGoDotTplBytes, nil
	case "foji/openapi/stub.yaml.tpl":
		return FojiSlashOpenapiSlashStubDotYamlDotTplBytes, nil
	case "foji/pgx/db.go.tpl":
		return FojiSlashPgxSlashDbDotGoDotTplBytes, nil
	case "foji/pgx/model.go.tpl":
		return FojiSlashPgxSlashModelDotGoDotTplBytes, nil
	case "foji/pgx/table.go.tpl":
		return FojiSlashPgxSlashTableDotGoDotTplBytes, nil
	case "foji.yaml":
		return FojiDotYamlBytes, nil
	case "init.yaml":
		return InitDotYamlBytes, nil
	}

	return nil, os.ErrNotExist
}

func GetString(filename string) (string, error) {
	switch filename {
	case "foji/dbList.console.tpl":
		return FojiSlashDbListDotConsoleDotTpl, nil
	case "foji/embed.go.tpl":
		return FojiSlashEmbedDotGoDotTpl, nil
	case "foji/enum.go.tpl":
		return FojiSlashEnumDotGoDotTpl, nil
	case "foji/fields.go.tpl":
		return FojiSlashFieldsDotGoDotTpl, nil
	case "foji/sqlRepo.go.tpl":
		return FojiSlashSqlRepoDotGoDotTpl, nil
	case "foji/openapi/auth.go.tpl":
		return FojiSlashOpenapiSlashAuthDotGoDotTpl, nil
	case "foji/openapi/docs.go.tpl":
		return FojiSlashOpenapiSlashDocsDotGoDotTpl, nil
	case "foji/openapi/handler.go.tpl":
		return FojiSlashOpenapiSlashHandlerDotGoDotTpl, nil
	case "foji/openapi/main.go.tpl":
		return FojiSlashOpenapiSlashMainDotGoDotTpl, nil
	case "foji/openapi/model.go.tpl":
		return FojiSlashOpenapiSlashModelDotGoDotTpl, nil
	case "foji/openapi/service.go.tpl":
		return FojiSlashOpenapiSlashServiceDotGoDotTpl, nil
	case "foji/openapi/stub.yaml.tpl":
		return FojiSlashOpenapiSlashStubDotYamlDotTpl, nil
	case "foji/pgx/db.go.tpl":
		return FojiSlashPgxSlashDbDotGoDotTpl, nil
	case "foji/pgx/model.go.tpl":
		return FojiSlashPgxSlashModelDotGoDotTpl, nil
	case "foji/pgx/table.go.tpl":
		return FojiSlashPgxSlashTableDotGoDotTpl, nil
	case "foji.yaml":
		return FojiDotYaml, nil
	case "init.yaml":
		return InitDotYaml, nil
	}

	return "", os.ErrNotExist
}

// foji/dbList.console.tpl
var FojiSlashDbListDotConsoleDotTplBytes = []byte(FojiSlashDbListDotConsoleDotTpl)

const FojiSlashDbListDotConsoleDotTpl = `{{- range $key, $value := .DB -}}
Schema: {{red}}{{$key}}{{colorReset}}
{{- range $value.Tables }}
  {{ pascal .Type }}: {{yellow}}{{ case .Name }}{{colorReset}}
  {{- if .ReadOnly }}  {{red}}readonly{{colorReset}} {{end}}
  {{- magenta}}  {{ .Comment }}{{colorReset}}
    Columns{{range .Columns }}
      {{green}}{{ pad (case .Name) (cases .Table.Columns.Names).Max }} {{colorReset}}  {{ pad .Type .Table.Columns.Types.Max }}  {{ if not .Nullable }}NOT NULL{{end}}  {{ if .IsPrimaryKey }}PK{{end}} {{magenta}}{{ .Comment }}{{colorReset}}
    {{- end }}
    {{- if not (empty .Indexes)}}
    Indexes{{range .Indexes }}
      {{ case .Name }} {{ (cases .Columns.Names).Join "," }} {{ if not .IsUnique }}UNIQUE{{end}} {{ if .IsPrimary }}{{cyan}}PK{{colorReset}}{{end}} {{magenta}}{{ .Comment }}{{colorReset}}
    {{- end }}{{end}}
    {{- if not (empty .ForeignKeys)}}
    ForeignKeys{{range .ForeignKeys }}
      {{ case .Name }} ({{ (cases .Columns.Names).Join "," }}) -> {{ case .ForeignTable.Name }}({{ (cases .ForeignColumns.Names).Join "," }}) {{magenta}}{{ .Comment }}{{colorReset}}
    {{- end }}{{end}}
    {{- if not (empty .References)}}
    References{{range .References }}
      {{ case .Name }} {{ .Table.Name }}({{ (cases .Columns.Names).Join "," }}) -> ({{ (cases .ForeignColumns.Names).Join "," }}) {{magenta}}{{ .Comment }}{{colorReset}}
    {{- end }}{{end}}
{{ end }}
{{- range $value.Enums }}
  enum: {{yellow}}{{ case .Name }}{{colorReset}} {{magenta}}{{ .Comment }}{{colorReset}}
    {{- range .Values }}
      {{green}}{{ case . }}{{colorReset}}
    {{- end }}
{{- end }}
{{- end }}`

// foji/embed.go.tpl
var FojiSlashEmbedDotGoDotTplBytes = []byte(FojiSlashEmbedDotGoDotTpl)

const FojiSlashEmbedDotGoDotTpl = `// Code generated by foji {{ version }}, template: {{ templateFile }}; DO NOT EDIT.

package {{ .PackageName }}

import "os"

func List() []string {
	return []string{
{{- range .FileGroups }}
	{{- range .Files }}
		"{{ .Name }}",
	{{- end }}
{{- end}}
		}
}

func Get(filename string) ([]byte, error) {
	switch filename {
{{- range .FileGroups }}
{{- range .Files }}
	case "{{ .Name }}":
		return {{ case (goToken .Name) }}Bytes, nil
{{- end }}
{{- end}}
	}

	return nil, os.ErrNotExist
}

func GetString(filename string) (string, error) {
	switch filename {
{{- range .FileGroups }}
{{- range .Files }}
	case "{{ .Name }}":
		return {{ case (goToken .Name) }}, nil
{{- end }}
{{- end}}
	}

	return "", os.ErrNotExist
}
{{- range .FileGroups }}
{{- range .Files }}

// {{.Name}}
var {{ case (goToken .Name) }}Bytes = []byte({{ case (goToken .Name) }})
const {{ case (goToken .Name) }} = ` + "`" + `{{ backQuote (toString .Content) }}` + "`" + `
{{- end -}}
{{end -}}`

// foji/enum.go.tpl
var FojiSlashEnumDotGoDotTplBytes = []byte(FojiSlashEnumDotGoDotTpl)

const FojiSlashEnumDotGoDotTpl = `// Code generated by foji {{ version }}, template: {{ templateFile }}; DO NOT EDIT.

package {{ .PackageName }}

import (
	"database/sql/driver"
	"fmt"

{{- range .Imports }}
	"{{ . }}"
{{- end }}

)

{{- $type := case .Enum.Name }}

// {{ $type }} is the '{{ .Enum.Name }}' enum type from schema '{{ .Enum.Schema.Name  }}'.
type {{ $type }} uint16

const (
	// Unknown{{$type}} defines an invalid {{$type}}.
	Unknown{{$type}} {{$type}} = iota
{{- range .Enum.Values }}
	{{ case . }}{{ $type }}
{{- end }}
)

// String returns the string value of the {{ $type }}.
func (e {{ $type }}) String() string {
	switch e {
{{- range .Enum.Values }}
	case {{ case . }}{{ $type }}:
		return "{{ . }}"
{{- end }}
	default:
		return "Unknown{{$type}}"
	}
}

// MarshalText marshals {{ $type }} into text.
func (e {{ $type }}) MarshalText() ([]byte, error) {
	return []byte(e.String()), nil
}

// UnmarshalText unmarshals {{ $type }} from text.
func (e *{{ $type }}) UnmarshalText(text []byte) error {
	val, err := Parse{{$type}}(string(text))
	if err != nil {
		return err
	}
	*e = val
	return nil
}

// Parse{{$type}} converts s into a {{$type}} if it is a valid
// stringified value of {{$type}}.
func Parse{{$type}}(s string) ({{$type}}, error) {
	switch s {
{{- range .Enum.Values }}
	case "{{ . }}":
		return {{ case . }}{{ $type }}, nil
{{- end }}
	default:
		return Unknown{{$type}}, fmt.Errorf("invalid {{ $type }}")
	}
}

// Value satisfies the sql/driver.Valuer interface for {{ $type }}.
func (e {{ $type }}) Value() (driver.Value, error) {
	return e.String(), nil
}

// Scan satisfies the database/sql.Scanner interface for {{ $type }}.
func (e *{{ $type }}) Scan(src interface{}) error {
	buf, ok := src.([]byte)
	if !ok {
		return errors.New("invalid {{ $type }}")
	}

	return e.UnmarshalText(buf)
}

// {{$type}}Field is a component that returns a {{ $.PackageName }}.Where that contains a
// comparison based on its field and a strongly typed value.
type {{$type}}Field string

// Equals returns a {{$.PackageName}}.WhereClause for this field.
func (f {{$type}}Field) Equals(v {{$type}}) {{$.PackageName}}.Where {
	return {{$.PackageName}}.Where{
		Field: string(f),
		Comp:  {{$.PackageName}}.CompEqual,
		Value: v,
	}
}

// GreaterThan returns a {{$.PackageName}}.Where for this field.
func (f {{$type}}Field) GreaterThan(v {{$type}}) {{$.PackageName}}.Where {
	return {{$.PackageName}}.Where{
		Field: string(f),
		Comp:  {{$.PackageName}}.CompGreater,
		Value: v,
	}
}

// LessThan returns a {{$.PackageName}}.Where for this field.
func (f {{$type}}Field) LessThan(v {{$type}}) {{$.PackageName}}.Where {
	return {{$.PackageName}}.Where{
		Field: string(f),
		Comp:  {{$.PackageName}}.CompEqual,
		Value: v,
	}
}

// GreaterOrEqual returns a {{$.PackageName}}.Where for this field.
func (f {{$type}}Field) GreaterOrEqual(v {{$type}}) {{$.PackageName}}.Where {
	return {{$.PackageName}}.Where{
		Field: string(f),
		Comp:  {{$.PackageName}}.CompGTE,
		Value: v,
	}
}

// LessOrEqual returns a {{$.PackageName}}.Where for this field.
func (f {{$type}}Field) LessOrEqual(v {{$type}}) {{$.PackageName}}.Where {
	return {{$.PackageName}}.Where{
		Field: string(f),
		Comp:  {{$.PackageName}}.CompLTE,
		Value: v,
	}
}

// NotEqual returns a {{$.PackageName}}.Where for this field.
func (f {{$type}}Field) NotEqual(v {{$type}}) {{$.PackageName}}.Where {
	return {{$.PackageName}}.Where{
		Field: string(f),
		Comp:  {{$.PackageName}}.CompNE,
		Value: v,
	}
}

// In returns a {{$.PackageName}}.Where for this field.
func (f {{$type}}Field) In(vals []{{$type}}) {{$.PackageName}}.InClause {
	values := make([]interface{}, len(vals))
	for x := range vals {
		values[x] = vals[x]
	}
	return {{$.PackageName}}.InClause{
		Field: string(f),
		Vals:  values,
	}
}
`

// foji/fields.go.tpl
var FojiSlashFieldsDotGoDotTplBytes = []byte(FojiSlashFieldsDotGoDotTpl)

const FojiSlashFieldsDotGoDotTpl = `// Code generated by foji {{ version }}, template: {{ templateFile }}; DO NOT EDIT.

package {{ .PackageName }}

import (
	"bytes"
	"database/sql"
	"database/sql/driver"
	"encoding/json"
	"errors"
	"fmt"
	"strconv"
	"strings"
	"time"

	"github.com/google/uuid"
)

var errByteArrayCast = errors.New("type assertion .([]byte) failed")
var errJsonbCast = errors.New("reading from DB into Jsonb, failed to convert to map[string]interface{}")

// Bytea is a wrapper around byte arrays specifically for bytea column types in postgres.
type Bytea []byte

// Jsonb is a wrapper for map[string]interface{} for storing json into postgres
type Jsonb map[string]interface{}

// Value marshals the json into the database
func (j Jsonb) Value() (driver.Value, error) {
	return json.Marshal(j)
}

// Scan Unmarshalls the bytes[] back into a Jsonb object
func (j *Jsonb) Scan(src interface{}) error {
	source, ok := src.([]byte)
	if !ok {
		return errByteArrayCast
	}

	var i map[string]interface{}
	err := json.Unmarshal(source, &i)
	if err != nil {
		return err
	}
	*j = i

	return nil
}

type OrderByClause interface {
	String() string
}

// OrderByDesc returns a sort order descending by the given field.
func OrderByDesc(field string) OrderBy {
	return OrderBy{
		Field: field,
		Order: OrderDesc,
	}
}

// OrderByAsc returns a sort order ascending by the given field.
func OrderByAsc(field string) OrderBy {
	return OrderBy{
		Field: field,
		Order: OrderAsc,
	}
}

// OrderBy indicates how rows should be sorted.
type OrderBy struct {
	Field string
	Order SortOrder
}

func (o OrderBy) String() string {
	if o.Order == OrderNone {
		return ""
	}
	return " ORDER BY " + o.Field + " " + o.Order.String() + " "
}

// SortOrder defines how to order rows returned.
type SortOrder int

// Defined sort orders for not sorted, descending and ascending.
const (
	OrderNone SortOrder = iota
	OrderDesc
	OrderAsc
)

// String returns the sql string representation of this sort order.
func (s SortOrder) String() string {
	switch s {
	case OrderDesc:
		return "DESC"
	case OrderAsc:
		return "ASC"
	}
	return ""
}

// WhereClause has a String function should return a properly formatted where
// clause (not including the WHERE) for positional arguments starting at idx.
type WhereClause interface {
	String(idx *int) string
	Values() []interface{}
}

// Comparison is used by WhereClauses to create valid sql.
type Comparison string

// Comparison types.
const (
	CompEqual   Comparison = " = "
	CompGreater Comparison = " > "
	CompLess    Comparison = " < "
	CompGTE     Comparison = " >= "
	CompLTE     Comparison = " <= "
	CompNE      Comparison = " <> "
)

type Where struct {
	Field string
	Comp  Comparison
	Value interface{}
}

func (w Where) String(idx *int) string {
	ret := w.Field + string(w.Comp) + "$" + strconv.Itoa(*idx)
	(*idx)++
	return ret
}

func (w Where) Values() []interface{} {
	return []interface{}{w.Value}
}

// NullClause is a clause that checks for a column being null or not.
type NullClause struct {
	Field string
	Null  bool
}

func (n NullClause) String(_ *int) string {
	if n.Null {
		return n.Field + " IS NULL "
	}
	return n.Field + " IS NOT NULL "
}

func (n NullClause) Values() []interface{} {
	return []interface{}{}
}

// AndClause returns a WhereClause that serializes to the AND
// of all the given where clauses.
func AndClause(wheres ...WhereClause) WhereClause {
	return andClause(wheres)
}

type andClause []WhereClause

func (a andClause) String(idx *int) string {
	wheres := make([]string, len(a))
	for x := 0; x < len(a); x++ {
		wheres[x] = a[x].String(idx)
	}
	return strings.Join(wheres, " AND ")
}

func (a andClause) Values() []interface{} {
	vals := make([]interface{}, 0, len(a))
	for x := 0; x < len(a); x++ {
		vals = append(vals, a[x].Values()...)
	}
	return vals
}

// OrClause returns a WhereClause that serializes to the OR
// of all the given where clauses.
func OrClause(wheres ...WhereClause) WhereClause {
	return orClause(wheres)
}

type orClause []WhereClause

func (o orClause) String(idx *int) string {
	wheres := make([]string, len(o))
	for x := 0; x < len(wheres); x++ {
		wheres[x] = o[x].String(idx)
	}
	return strings.Join(wheres, " OR ")
}

func (o orClause) Values() []interface{} {
	vals := make([]interface{}, len(o))
	for x := 0; x < len(o); x++ {
		vals = append(vals, o[x].Values()...)
	}
	return vals
}

// InClause takes a slice of values that it matches against.
type InClause struct {
	Field  string
	Vals []interface{}
}

func (in InClause) String(idx *int) string {
	ret := in.Field + " in ("
	for x := range in.Vals {
		if x != 0 {
			ret += ", "
		}
		ret += "$" + strconv.Itoa(*idx)
		(*idx)++
	}
	ret += ")"
	return ret
}

func (in InClause) Values() []interface{} {
	return in.Vals
}

type PrefixMatch struct {
	Field string
	Value interface{}
}

func (w PrefixMatch) String(idx *int) string {
	ret := "$" + strconv.Itoa(*idx) + " ILIKE " + w.Field
	(*idx)++
	return ret
}

func (w PrefixMatch) Values() []interface{} {
	return []interface{}{w.Value}
}


type PInt32 *int32
type PString *string

func NewPInt32(i int32) PInt32{
  return &i
}

// Time is a nullable time.Time. It supports SQL and JSON serialization.
// It will marshal to null if null.
type Time struct {
	sql.NullTime
}

// Value implements the driver Valuer interface.
func (t Time) Value() (driver.Value, error) {
	if !t.Valid {
		return nil, nil
	}
	return t.Time, nil
}

// TimeFrom creates a new Time that will always be valid.
func TimeFrom(t time.Time) Time {
	return Time{
		NullTime: sql.NullTime{
			Time:  t,
			Valid: true,
		},
	}
}

// MarshalJSON implements json.Marshaler.
// It will encode null if this time is null.
func (t Time) MarshalJSON() ([]byte, error) {
	if !t.Valid {
		return []byte("null"), nil
	}
	return t.Time.MarshalJSON()
}

// nullBytes is a JSON null literal
var nullBytes = []byte("null")

// UnmarshalJSON implements json.Unmarshaler.
// It supports string and null input.
func (t *Time) UnmarshalJSON(data []byte) error {
	if bytes.Equal(data, nullBytes) {
		t.Valid = false
		return nil
	}

	if err := json.Unmarshal(data, &t.Time); err != nil {
		return fmt.Errorf("null: couldn't unmarshal JSON: %w", err)
	}

	t.Valid = true
	return nil
}

// MarshalText implements encoding.TextMarshaler.
// It returns an empty string if invalid, otherwise time.Time's MarshalText.
func (t Time) MarshalText() ([]byte, error) {
	if !t.Valid {
		return []byte{}, nil
	}
	return t.Time.MarshalText()
}

// UnmarshalText implements encoding.TextUnmarshaler.
// It has backwards compatibility with v3 in that the string "null" is considered equivalent to an empty string
// and unmarshaling will succeed. This may be removed in a future version.
func (t *Time) UnmarshalText(text []byte) error {
	str := string(text)
	// allowing "null" is for backwards compatibility with v3
	if str == "" || str == "null" {
		t.Valid = false
		return nil
	}
	if err := t.Time.UnmarshalText(text); err != nil {
		return fmt.Errorf("null: couldn't unmarshal text: %w", err)
	}
	t.Valid = true
	return nil
}

// SetValid changes this Time's value and sets it to be non-null.
func (t *Time) SetValid(v time.Time) {
	t.Time = v
	t.Valid = true
}

// Ptr returns a pointer to this Time's value, or a nil pointer if this Time is null.
func (t Time) Ptr() *time.Time {
	if !t.Valid {
		return nil
	}
	return &t.Time
}

// IsZero returns true for invalid Times, hopefully for future omitempty support.
// A non-null Time with a zero value will not be considered zero.
func (t Time) IsZero() bool {
  return !t.Valid
}

// Equal returns true if both Time objects encode the same time or are both null.
// Two times can be equal even if they are in different locations.
// For example, 6:00 +0200 CEST and 4:00 UTC are Equal.
func (t Time) Equal(other Time) bool {
  return t.Valid == other.Valid && (!t.Valid || t.Time.Equal(other.Time))
}

// ExactEqual returns true if both Time objects are equal or both null.
// ExactEqual returns false for times that are in different locations or
// have a different monotonic clock reading.
func (t Time) ExactEqual(other Time) bool {
  return t.Valid == other.Valid && (!t.Valid || t.Time == other.Time)
}

{{ range (toSlice "PString" "PInt32" "Jsonb" "int" "int32" "string"  "int64" "float64" "bool"  "time.Time" "Time" "uint32" "uuid.UUID") }}
{{ $fieldName := title (replace "." "" .) }}// {{$fieldName}}Field is a component that returns a WhereClause that contains a
// comparison based on its field and a strongly typed value.
type {{$fieldName}}Field string

// OrderBy returns a OrderByClause for this field.
func (f {{$fieldName}}Field) OrderBy(v SortOrder) OrderByClause {
	return OrderBy{
		Field: string(f),
		Order:  v,
	}
}

// OrderByAsc returns a OrderByClause for this field.
func (f {{$fieldName}}Field) OrderByAsc() OrderByClause {
	return OrderBy{
		Field: string(f),
		Order:  OrderAsc,
	}
}

// OrderByDesc returns a OrderByClause for this field.
func (f {{$fieldName}}Field) OrderByDesc() OrderByClause {
	return OrderBy{
		Field: string(f),
		Order:  OrderDesc,
	}
}

// Equals returns a WhereClause for this field.
func (f {{$fieldName}}Field) Equals(v {{.}}) Where {
	return Where{
		Field: string(f),
		Comp:  CompEqual,
		Value: v,
	}
}

// GreaterThan returns a WhereClause for this field.
func (f {{$fieldName}}Field) GreaterThan(v {{.}}) Where {
	return Where{
		Field: string(f),
		Comp:  CompGreater,
		Value: v,
	}
}

// LessThan returns a WhereClause for this field.
func (f {{$fieldName}}Field) LessThan(v {{.}}) Where {
	return Where{
		Field: string(f),
		Comp:  CompLess,
		Value: v,
	}
}

// GreaterOrEqual returns a WhereClause for this field.
func (f {{$fieldName}}Field) GreaterOrEqual(v {{.}}) Where {
	return Where{
		Field: string(f),
		Comp:  CompGTE,
		Value: v,
	}
}

// LessOrEqual returns a WhereClause for this field.
func (f {{$fieldName}}Field) LessOrEqual(v {{.}}) Where {
	return Where{
		Field: string(f),
		Comp:  CompLTE,
		Value: v,
	}
}

// NotEqual returns a WhereClause for this field.
func (f {{$fieldName}}Field) NotEqual(v {{.}}) Where {
	return Where{
		Field: string(f),
		Comp:  CompNE,
		Value: v,
	}
}

// In returns a WhereClause for this field.
func (f {{$fieldName}}Field) In(vals ...{{.}}) InClause {
	values := make([]interface{}, len(vals))
	for x := range vals {
		values[x] = vals[x]
	}
	return InClause{
		Field: string(f),
		Vals: values,
	}
}

{{end}}

{{ range (toSlice  "PString" "PInt32" "Jsonb" "Time" ) }}
{{ $fieldName := title (replace "." "" .) }}
// IsNull returns a WhereClause that matches when this field is NULL.
func (f {{$fieldName}}Field) IsNull() NullClause {
	return NullClause{
		Field: string(f),
		Null: true,
	}
}

// IsNotNull returns a WhereClause that matches when this field is not NULL.
func (f {{$fieldName}}Field) IsNotNull() NullClause {
	return NullClause{
		Field: string(f),
		Null: false,
	}
}

{{end}}

// InterfaceField is a component that returns a WhereClause that contains a
// comparison based on its field and a strongly typed value.  Currently interface{} is not supported.
type InterfaceField string

`

// foji/sqlRepo.go.tpl
var FojiSlashSqlRepoDotGoDotTplBytes = []byte(FojiSlashSqlRepoDotGoDotTpl)

const FojiSlashSqlRepoDotGoDotTpl = `// Code generated by foji {{ version }}, template: {{ templateFile }}; DO NOT EDIT.

package pg

import (
	"context"
	"fmt"

{{- range .Imports }}
	"{{ . }}"
{{- end }}
)

{{- range .Queries }}
{{ $resultType := $.GetType .Result.TypeParam $.PackageName }}

{{- if .Result.GenerateType }}
// {{.Result.Type}} represents a result from '{{.Name}}'.
type {{.Result.Type}} struct {
{{- range .Result.Params.ByOrdinal }}
	{{ pascal .Name }} {{ $.GetType . $.PackageName }}  ` + "`" + `json:"{{ .Name }},omitempty"` + "`" + ` // postgres type: {{ .Type }} {{- if .Nullable }} NULLABLE {{ end }}
{{- end }}
}
{{- end }}

// {{.Name}} returns {{ $resultType }}
{{- if notEmpty .Comment }}
// {{.Comment}}
{{- end }}
func (r Repo) {{ .Name }}(ctx context.Context{{if gt (len .Params) 0}}, {{end}}{{ $.Parameterize .Params.ByOrdinal "%s %s" $.PackageName }}) ({{ if .IsType "query" }}[]{{ end }}*{{$resultType}}, error) {
	const query = ` + "`" + `{{ backQuote .SQL }}` + "`" + `

{{- if .IsType "query" }}
	q, err := r.db.Query(ctx, query{{if gt (len .Params) 0}}, {{ csv (.Params.ByQuery.Names.Camel)}}{{end}})
	if err != nil {
		return nil, fmt.Errorf("{{.Name}}.Query:%w", err)
	}

	var out []*{{ $resultType }}

	for q.Next() {
		row := {{ $resultType }}{}
		err := q.Scan({{ csv (.Result.Params.ByQuery.Names.Pascal.Sprintf "&row.%s")}})
		if err != nil {
			return nil, fmt.Errorf("{{.Name}}.Scan:%w", err)
		}

		out = append(out, &row)
	}

	return out, nil
{{- else }}
	q := r.db.QueryRow(ctx, query{{if gt (len .Params) 0}},{{end}} {{ csv (.Params.ByQuery.Names.Camel) }})
	{{/*        return scanOne{{$goName}}(q)*/}}
{{- end }}
}
{{- end }}
`

// foji/openapi/auth.go.tpl
var FojiSlashOpenapiSlashAuthDotGoDotTplBytes = []byte(FojiSlashOpenapiSlashAuthDotGoDotTpl)

const FojiSlashOpenapiSlashAuthDotGoDotTpl = `{{ .NotNeededIf (not .HasAuthentication) "no security schemes" -}}
{{ .ErrorIf (empty $.Params.Auth) "params.Auth" -}}
// Code generated by foji {{ version }}, template: {{ templateFile }}; DO NOT EDIT.
{{ $packageName := $.PackageName }}
package {{$packageName}}

import (
	"context"
	"encoding/base64"
	"net/http"
	"strings"

	"github.com/bir/iken/httputil"
{{- .CheckAllTypes $packageName $.Params.Auth -}}
{{- range .GoImports }}
	"{{ . }}"
{{- end }}
)

type (
	// AuthenticateFunc is the signature of a function used to authenticate an http request.
	// Given a request, it returns the authenticated user.  If unable to authenticate the
	// request it returns an error.
	AuthenticateFunc = httputil.AuthenticateFunc[*{{ $.CheckPackage $.Params.Auth $packageName }}]

{{if .HasComplexAuth }}
	SecurityGroup  = httputil.SecurityGroup[*{{ $.CheckPackage $.Params.Auth $packageName }}]
	SecurityGroups = httputil.SecurityGroups[*{{ $.CheckPackage $.Params.Auth $packageName }}]
{{- end}}

{{- if .HasAuthorization }}
	AuthorizeFunc  = httputil.AuthorizeFunc[*{{ $.CheckPackage $.Params.Auth $packageName }}]
{{- end}}


// Authenticator takes a key (for example a bearer token) and returns the authenticated user.
	Authenticator = func(ctx context.Context, key string) (*{{ $.CheckPackage $.Params.Auth $packageName }}, error)

{{- if .HasBasicAuth }}

// BasicAuthenticator takes a user/pass pair and returns the authenticated user.
type BasicAuthenticator = func(user,pass string) (*{{ $.CheckPackage $.Params.Auth $packageName }}, error)
{{- end}}

)

{{- if or .HasBasicAuth .HasBearerAuth }}
var (
{{- if .HasBasicAuth }}
    basicAuthPrefix = "Basic "
{{- end}}
{{- if .HasBearerAuth }}
    bearerAuthPrefix = "Bearer "
{{- end}}
)
{{- end}}

{{- range $security, $value := .File.API.Components.SecuritySchemes }}
// {{ pascal $security }}Auth is responsible for extracting "{{$security}}" credentials from a request and calling the
// supplied Authenticator to authenticate
{{- goDoc $value.Value.Description }}
func {{ pascal $security }}Auth(fn {{if eq $value.Value.Scheme "basic"}}Basic{{end}}Authenticator) AuthenticateFunc {
	return func(r *http.Request) (*{{ $.CheckPackage $.Params.Auth $packageName }}, error) {
    {{- if eq $value.Value.Type "apiKey" }}
        {{- if eq $value.Value.In "query" }}
		key := r.URL.Query().Get("{{$value.Value.Name}}")
		if len(key) == 0 {
			return nil, httputil.ErrUnauthorized
		}
        {{- else if eq $value.Value.In "header" }}
		key := r.Header.Get("{{ $value.Value.Name }}")
		if len(key) == 0 {
			return nil, httputil.ErrUnauthorized
		}
        {{- else if eq $value.Value.In "cookie" }}
		cookie := r.Cookie("{{$value.Value.Name}}")
		if cookie == nil || len(cookie.Value) == 0 {
			return nil, httputil.ErrUnauthorized
		}

		key := cookie.Value
        {{end}}

		return fn(r.Context(), key)
    {{- else if eq $value.Value.Type "http" }}
        {{- if eq $value.Value.Scheme "bearer" }}
		key := r.Header.Get("Authorization")
		if len(key) == 0 {
			return nil, httputil.ErrUnauthorized
		}

		if strings.HasPrefix(key, bearerAuthPrefix){
			key = key[7:]
		}

		return fn(r.Context(), key)
        {{- else if eq $value.Value.Scheme "basic" }}
		key := r.Header.Get("Authorization")
		if len(key) == 0 {
			return nil, httputil.ErrBasicAuthenticate
		}

		payload, err := base64.StdEncoding.DecodeString(key[len(basicAuthPrefix):]))
		if err != nil {
			return nil, httputil.ErrBasicAuthenticate
		}

		pair := strings.SplitN(payload, []byte(":"), 2)
		if len(pair) != 2 {
			return nil, httputil.ErrUnauthorized
		}

		return fn(r.Context(), pair[0],pair[1])
        {{- end }}
    {{- else  }}
        // TODO: Support: {{ toJson $value }}
		return nil, httputil.ErrUnauthorized
    {{- end }}
	}
}
{{- end }}
`

// foji/openapi/docs.go.tpl
var FojiSlashOpenapiSlashDocsDotGoDotTplBytes = []byte(FojiSlashOpenapiSlashDocsDotGoDotTpl)

const FojiSlashOpenapiSlashDocsDotGoDotTpl = `// Code generated by foji {{ version }}, template: {{ templateFile }}; DO NOT EDIT.

package {{ .PackageName }}

import (
	"net/http"

	"github.com/bir/iken/httputil"
	"github.com/go-chi/chi/v5"
)

func Register(r chi.Router) {
	r.Get("/docs", httputil.RapiDoc(httputil.RapiDocOpts{SpecURL:"swagger.yaml"}))
	r.Get("/swagger.yaml", GetYaml)
}


func GetYaml(w http.ResponseWriter, r *http.Request) {

{{- range .FileGroups }}
	{{- range .Files }}
		_, err := w.Write({{ case (goToken .Name) }}Bytes)
	{{- end -}}
{{end }}
	if err != nil {
		httputil.ErrorHandler(w, r, err)

		return
	}
}
`

// foji/openapi/handler.go.tpl
var FojiSlashOpenapiSlashHandlerDotGoDotTplBytes = []byte(FojiSlashOpenapiSlashHandlerDotGoDotTpl)

const FojiSlashOpenapiSlashHandlerDotGoDotTpl = `{{- define "methodSignature"}}
    {{- $path := .RuntimeParams.path -}}
    {{- $op := .RuntimeParams.op -}}
    {{- $body := .GetRequestBody $op -}}
    {{- $package := .RuntimeParams.package -}}
    {{- if not (empty ($.OpSecurity $op)) }} user *{{ $.CheckPackage $.Params.Auth $package -}},{{- end }}
    {{- range $param := $.OpParams $path $op -}}
		{{- $name := (print $op.OperationID " " $param.Value.Name) -}}
        {{ goToken (camel $param.Value.Name) -}}
		{{- if notEmpty $param.Ref -}}
			{{- $name = $param.Value.Name -}}
		{{- end -}}
        {{- if $.ParamIsOptionalType $param }} *{{ end }} {{ $.GetType $package $name $param.Value.Schema }},
    {{- end -}}
    {{- if isNotNil $body}}
        {{- $type := $.GetType $package (print $op.OperationID "Request") $body.Schema }} body {{ $type  -}}
    {{- end -}}
	) (
    {{- $response := $.GetOpHappyResponseType $package .RuntimeParams.op}}
    {{- if notEmpty $response}}{{ $.CheckPackage $response $package}}, {{ end }}error)
{{- end -}}


{{- define "paramExtraction" -}}
    {{- $op := .RuntimeParams.op }}
    {{- $param := .RuntimeParams.param }}
    {{- $package := .RuntimeParams.package }}
    {{- $goType := $.GetType $package (print $op.OperationID " " $param.Value.Name) $param.Value.Schema }}
	{{- if notEmpty $param.Ref -}}
        {{- $goType = $.GetType $package $param.Value.Name $param.Value.Schema  }}
	{{- end -}}
    {{- $enumNew := $.EnumNew $goType }}
    {{- $required := $param.Value.Required }}
    {{- $hasDefault := isNotNil $param.Value.Schema.Value.Default }}
    {{- $isEnum := $.ParamIsEnum $param }}
    {{- $isArrayEnum := $.ParamIsEnumArray $param }}
    {{- $getRequiredParamFunction := "" -}}
    {{- if eq $param.Value.Schema.Value.Type "array" -}}
        {{- if eq $goType "[]int32" -}}
            {{- $getRequiredParamFunction = "GetInt32Array" -}}
        {{- else if $isArrayEnum }}
            {{- $getRequiredParamFunction = "GetEnumArray" -}}
        {{- else }}
            {{- $getRequiredParamFunction = "GetStringArray" -}}
        {{- end -}}
    {{- else -}}
        {{- if eq $goType "bool" -}}
            {{- $getRequiredParamFunction = "GetBool" -}}
        {{- else if eq $goType "int32" -}}
            {{- $getRequiredParamFunction = "GetInt32" -}}
        {{- else if eq $goType "int64" -}}
            {{- $getRequiredParamFunction = "GetInt64" -}}
        {{- else if eq $goType "time.Time" }}
            {{- $getRequiredParamFunction = "GetTime" -}}
        {{- else if $isEnum }}
            {{- $getRequiredParamFunction = "GetEnum" -}}
        {{- else }}
            {{- $getRequiredParamFunction = "GetString" -}}
        {{- end -}}
    {{- end -}}
{{- goDoc $param.Value.Description }}
	{{- if eq $param.Value.Schema.Value.Type "array" }}
	{{ goToken (camel $param.Value.Name) }}, _, err := params.{{ $getRequiredParamFunction }}(r, "{{ $param.Value.Name }}", {{ $required }}
		{{- if $isArrayEnum -}}, {{ $enumNew  }}{{- end -}})
	if err != nil {
		validationErrors.Add("{{ $param.Value.Name }}", err)
	}
		{{ if $hasDefault }}
	if len({{ goToken (camel $param.Value.Name) }}) == 0 {
	    {{ goToken (camel $param.Value.Name) }} = {{$goType}}{
		    {{- range $val := $.DefaultValues  $param.Value.Schema.Value.Default}}
        {{ if $isArrayEnum}}{{$.StripArray $goType}}{{ pascal (goToken $val) }}{{else}}{{ printf "%#v" $param.Value.Schema.Value.Default }}{{end}},
			{{end}}
		}
	}
		{{end}}


	{{- else if $required }}
	{{ goToken (camel $param.Value.Name) }}, _, err := params.{{ $getRequiredParamFunction }}(r, "{{ $param.Value.Name }}", {{ $required }}
		{{- if or $isEnum $isArrayEnum -}}, {{ $enumNew  }}{{- end -}})
	if err != nil {
		validationErrors.Add("{{ $param.Value.Name }}", err)
	}


	{{- else if $hasDefault }}
	{{ goToken (camel $param.Value.Name) }}, ok, err := params.{{ $getRequiredParamFunction }}(r, "{{ $param.Value.Name }}", {{ $required }}
    {{- if $isEnum -}}, {{ $enumNew  }}{{- end -}})
	if err != nil {
		validationErrors.Add("{{ $param.Value.Name }}", err)
	} else if !ok {
	    {{ goToken (camel $param.Value.Name) }} = {{ if $isEnum -}}
			{{- $goType}}{{ pascal (goToken (printf "%#v" $param.Value.Schema.Value.Default)) }}
		{{else -}}
			{{- if and (eq $goType "time.Time") (eq $param.Value.Schema.Value.Default "") -}}
                time.Time{}
            {{else -}}
				{{ printf "%#v" $param.Value.Schema.Value.Default }}
			{{- end}}
		{{- end}}
	}


	{{- else }}
	var {{ goToken (camel $param.Value.Name) }} *{{$goType}}

	{{ goToken (camel $param.Value.Name) }}Val, ok, err := params.{{ $getRequiredParamFunction }}(r, "{{ $param.Value.Name }}", {{ $required }}
    {{- if $isEnum -}}, {{ $enumNew  }}{{- end -}})
	if err != nil {
		validationErrors.Add("{{ $param.Value.Name }}", err)
	}

	if ok {
		{{ goToken (camel $param.Value.Name) }} = &{{ goToken (camel $param.Value.Name) }}Val
	}
	{{- end -}}

{{- end -}}
{{- $package := $.PackageName }}

// Code generated by foji {{ version }}, template: {{ templateFile }}; DO NOT EDIT.

package {{ $package }}

import (
	"context"
	"encoding/json"
	"errors"
	"io"
	"net/http"

	"github.com/bir/iken/httputil"
	"github.com/bir/iken/logctx"
	"github.com/bir/iken/params"
	"github.com/bir/iken/validation"
	"github.com/go-chi/chi/v5"
	"{{ $.Params.Package}}"
{{- .CheckAllTypes $package ($.Params.GetWithDefault "Auth" "") -}}
{{- range .GoImports }}
	"{{ . }}"
{{- end }}
)

type Operations interface {
{{- range $name, $path := .API.Paths }}
    {{- range $verb, $op := $path.Operations }}
        {{- $opResponse := $.GetOpHappyResponse $package $op }}
	{{ pascal $op.OperationID}}(ctx context.Context,
        {{- template "methodSignature" ($.WithParams "op" $op "package" $package "path" $path) }}
    {{- end }}
{{- end }}
}

type OpenAPIHandlers struct {
	ops      Operations
{{- if .HasAuthentication }}
    {{- range $security, $value := .API.Components.SecuritySchemes }}
	{{ camel $security }}Auth AuthenticateFunc
    {{- end }}
{{- if .HasAuthorization }}
    authorize AuthorizeFunc
{{- end}}
{{- end}}
{{- range $name, $path := .API.Paths }}
    {{- range $verb, $op := $path.Operations }}
        {{- if not ($.IsSimpleAuth $op) }}
	{{ camel $op.OperationID}}Security SecurityGroups
        {{- end}}
    {{- end}}
{{- end}}
}

func RegisterHTTP(ops Operations, r chi.Router
{{- if .HasAuthentication }}
	{{- range $security, $value := .API.Components.SecuritySchemes -}}
    , {{ camel $security }}Auth
	{{- end }} AuthenticateFunc
	{{- if .HasAuthorization -}}
    , authorize AuthorizeFunc
	{{- end -}}
{{- end -}}
) *OpenAPIHandlers {
	s := OpenAPIHandlers{ops: ops
{{- if .HasAuthentication }}
	{{- range $security, $value := .API.Components.SecuritySchemes -}}
    , {{ camel $security }}Auth: {{ camel $security }}Auth
	{{- end -}}
	{{- if .HasAuthorization -}}
	, authorize: authorize{{- end -}}
{{- end -}}
}

{{- range $name, $path := .API.Paths }}
    {{- range $verb, $op := $path.Operations }}
        {{- if not ($.IsSimpleAuth $op) }}

	s.{{ camel $op.OperationID}}Security = SecurityGroups{
            {{- $securityList := $.OpSecurity $op }}
            {{- range $securityGroup := $securityList }}
		SecurityGroup{
                {{- range $security, $scopes := $securityGroup -}}
					httputil.NewAuthCheck({{camel $security}}Auth
                    {{- if not (empty $scopes) -}}
						, authorize
                        {{- range $scopes -}}
							, "{{.}}"
                        {{- end -}}
                    {{- else -}}
						, nil
                    {{- end -}}
					),
                {{- end -}}
				},
            {{- end -}}
	}
        {{- end}}
    {{- end}}
{{- end}}

{{ range $name, $path := .API.Paths }}
    {{- range $verb, $op := $path.Operations }}
	r.{{pascal $verb}}("{{$name}}", http.HandlerFunc(s.{{ pascal $op.OperationID}}))
    {{- end }}
{{- end }}

	return &s
}

{{- range $name, $path := .API.Paths }}
    {{- range $verb, $op := $path.Operations }}
        {{- $opResponse := $.GetOpHappyResponse $package $op }}
        {{- $opBody := $.GetRequestBody $op }}

{{ goDoc (pascal $op.OperationID) }}
{{- goDoc $op.Summary }}
{{- goDoc $op.Description }}
func (h OpenAPIHandlers) {{ pascal $op.OperationID}}(w http.ResponseWriter, r *http.Request) {
	var err error
        {{- $securityList := $.OpSecurity $op }}

	logctx.AddStrToContext(r.Context(), "op", "{{$op.OperationID}}")

        {{- if $.IsSimpleAuth $op }}
            {{- $lastAuth := "" }}
            {{- range $securityGroup := $securityList }}
                {{- range $security, $scopes := $securityGroup }}
                    {{- if eq $lastAuth $security }}
                    {{- else }}

	user, err := h.{{ camel $security }}Auth(r)
                        {{- $lastAuth = $security -}}
                    {{- end -}}
                {{- end -}}
            {{- end }}
            {{- $authCt := 0 }}
            {{- range $securityGroup := $securityList }}
                {{- range $security, $scopes := $securityGroup }}
                    {{- if not (empty $scopes) }}
                        {{- if eq $authCt 0 }}
	if err == nil {
                        {{- else }}
	if err != nil {
                        {{- end }}
		err = h.authorize(r.Context(), user, []string{ {{range $scopes}}"{{.}}", {{end}} })
                        {{- $authCt = inc $authCt }}
                    {{- end}}
                {{- end}}
            {{- end}}
            {{- repeat $authCt "}\n" }}
        {{- else }}

	user, err := h.{{ camel $op.OperationID}}Security.Auth(r)
        {{- end -}}
        {{- if $.HasAnyAuth $op }}
	if err != nil {
		httputil.ErrorHandler(w, r, err)

		return
	}
        {{- end}}
        {{- if not (empty ($.OpParams $path $op)) }}

	var validationErrors validation.Errors
        {{- range $param := $.OpParams $path $op }}

	{{ template "paramExtraction" ($.WithParams "param" $param "package" $package "op" $op) }}
        {{- end }}

	if validationErrors != nil {
		httputil.ErrorHandler(w, r, validationErrors.GetErr())

		return
	}
		{{- end}}

        {{- $hasBody := not (empty $opBody)}}
		{{- if $hasBody }}
			{{- $bodyType := $.GetType $package (print (pascal $op.OperationID) "Request") $opBody.Schema}}
			{{- if $opBody.IsJson }}

	var body {{ $bodyType }}
	if err = httputil.GetJSONBody(r.Body, &body); err != nil {
		httputil.ErrorHandler(w, r, err)

		return
	}
        	{{- end }}
			{{- if $opBody.IsText }}

	b, err := io.ReadAll(r.Body)
	if err != nil {
		httputil.ErrorHandler(w, r, validation.Error{Message:"unable to read body", Source:err})

		return
	}

	body := string(b)
        	{{- end -}}
        {{- end -}}

        {{- $responseGoType := $opResponse.GoType}}
        {{- if notEmpty $responseGoType }}

	response, err := h.ops.{{ pascal $op.OperationID}}(r.Context(),
        {{- else}}

	err = h.ops.{{ pascal $op.OperationID}}(r.Context(),
        {{- end}}
        {{- if not (empty $securityList) }} user,{{- end -}}
        {{- range $param := $.OpParams $path $op}} {{ goToken (camel $param.Value.Name) }},{{- end -}}
        {{- if $hasBody }} body{{- end -}}

        )
	if err != nil {
		httputil.ErrorHandler(w, r, err)

		return
	}

        {{- $key := $.GetOpHappyResponseKey $op }}
        {{- if notEmpty $responseGoType }}
			{{- if $opResponse.IsJson }}

	httputil.JSONWrite(w, r, {{$key}}, response)
			{{- else if $opResponse.IsHTML }}

	httputil.HTMLWrite(w, r, {{$key}}, *response)
            {{- else if eq $responseGoType "[]byte" }}

	httputil.Write(w, r, "{{$opResponse.MimeType}}",  {{$key}}, response)
            {{- else if eq $responseGoType "io.Reader" }}

	httputil.ReaderWrite(w, r, "{{$opResponse.MimeType}}",  {{$key}}, response)
			{{- else }}

	httputil.Write(w, r, "{{$opResponse.MimeType}}",  {{$key}}, []byte(*response))
			{{- end -}}
        {{- else }}

	w.WriteHeader({{$key}})
        {{- end }}
}

    {{- end }}
{{- end }}
`

// foji/openapi/main.go.tpl
var FojiSlashOpenapiSlashMainDotGoDotTplBytes = []byte(FojiSlashOpenapiSlashMainDotGoDotTpl)

const FojiSlashOpenapiSlashMainDotGoDotTpl = `package main

import (
	"context"
	"errors"
	"fmt"
	"net/http"
	"os"
	"os/signal"
	"sync"
	"time"

	"github.com/bir/iken/config"
	"github.com/bir/iken/errs"
	"github.com/bir/iken/httplog"
	"github.com/go-chi/chi/v5"
	"github.com/lavaai/kit/auth"
	"github.com/rs/zerolog"
	"github.com/rs/zerolog/log"
	chiTrace "gopkg.in/DataDog/dd-trace-go.v1/contrib/go-chi/chi.v5"

	"{{ .Params.Package }}"
)

type Config struct {
	Debug               bool          ` + "`" + `env:"DEBUG"` + "`" + `
	Port                int           ` + "`" + `env:"PORT, 3500"` + "`" + `
	HttpWriteTimeout    time.Duration ` + "`" + `env:"HTTP_WRITE_TIMEOUT, 30s"` + "`" + `
	HttpReadTimeout     time.Duration ` + "`" + `env:"HTTP_READ_TIMEOUT, 30s"` + "`" + `
	HttpIdleTimeout     time.Duration ` + "`" + `env:"HTTP_IDLE_TIMEOUT, 50s"` + "`" + `
	HttpShutdownTimeout time.Duration ` + "`" + `env:"HTTP_SHUTDOWN_TIMEOUT, 5s"` + "`" + `
}

func main() {
	var cfg Config
	err := config.Load(&cfg)
	if err != nil {
		log.Fatal().Err(err).Msg("loading config")
	}

	l := setupLogging(true)

	router := chi.NewRouter().With(
		httplog.RecoverLogger(l),
		chiTrace.Middleware(),
		httplog.RequestLogger(httplog.LogAll),
	)

	svc :=  {{ $.PackageName }}.New()
	{{ $.PackageName }}.RegisterHTTP(svc, router
{{- if .HasAuthentication -}}
	{{- range $security, $value := .File.API.Components.SecuritySchemes -}}
	, {{ $.PackageName }}.{{ pascal $security }}Auth({{ pascal $security }}Auth)
	{{- end -}}
    {{- if .HasAuthorization -}}
	, Authorize
    {{- end -}}
{{- end -}}
)

	httpServer := http.Server{
		Addr:         fmt.Sprintf(":%d", cfg.Port),
		WriteTimeout: cfg.HttpWriteTimeout,
		ReadTimeout:  cfg.HttpReadTimeout,
		IdleTimeout:  cfg.HttpIdleTimeout,
		Handler:      router,
	}

	httpServerExit := make(chan int, 1)

	go func() {
		defer func() { httpServerExit <- 1 }()

		l.Info().Msgf("Serving on: http://%s", httpServer.Addr)
		if err := httpServer.ListenAndServe(); err != nil {
			if !errors.Is(err, http.ErrServerClosed) {
				log.Error().Stack().Err(err).Msg("HTTP Server error")
			}
		}
		log.Info().Msg("HTTP Server stopped")
	}()

	sigInt := make(chan os.Signal, 1)

	signal.Notify(sigInt, os.Interrupt) // We'll start graceful shutdowns when quit via SIGINT (Ctrl+C)

	var wg sync.WaitGroup // Block until we receive any signal.

	select {
	case <-sigInt:
		shutdownServer(&httpServer, cfg.HttpShutdownTimeout, &wg)
		log.Info().Msg("SIGINT received, shutting down.")
	case <-httpServerExit:
		log.Info().Msg("HTTP Server exited")
	}

	wg.Wait()

}

func setupLogging(consoleLog bool) zerolog.Logger {
	zerolog.DurationFieldInteger = true
	zerolog.DurationFieldUnit = time.Millisecond
	zerolog.ErrorStackMarshaler = errs.MarshalStack
	zerolog.TimeFieldFormat = zerolog.TimeFormatUnix

	if consoleLog {
		log.Logger = log.Output(zerolog.ConsoleWriter{Out: os.Stderr})
	}

	zerolog.DefaultContextLogger = &log.Logger

	return log.Logger
}

func shutdownServer(server *http.Server, duration time.Duration, wg *sync.WaitGroup) {
	wg.Add(1)

	go func() {
		defer wg.Done()

		ctx, cancel := context.WithTimeout(context.Background(), duration)
		defer cancel()

		err := server.Shutdown(ctx)
		if err != nil {
			log.Error().Stack().Err(err).Msg("Error shutting down server.")
		}
	}()
}

{{- if .HasAuthentication -}}
	{{- range $security, $value := .File.API.Components.SecuritySchemes }}

func {{ pascal $security }}Auth(ctx context.Context, key string) (*{{ $.CheckPackage $.Params.Auth "" }}, error){
	return nil, {{ $.PackageName }}.ErrNotImplemented
}
	{{- end -}}
    {{- if .HasAuthentication }}

func Authorize(ctx context.Context, user *auth.LavaUser, scopes []string) error {
	return form.ErrNotImplemented
}

{{- end -}}
{{- end -}}`

// foji/openapi/model.go.tpl
var FojiSlashOpenapiSlashModelDotGoDotTplBytes = []byte(FojiSlashOpenapiSlashModelDotGoDotTpl)

const FojiSlashOpenapiSlashModelDotGoDotTpl = `{{- define "propertyDeclaration"}}
    {{- $key := .RuntimeParams.key }}
    {{- $schema := .RuntimeParams.schema }}
    {{- $typeName := .RuntimeParams.typeName }}
    {{- goDoc $schema.Value.Description }}
    {{ pascal $key }} {{ $.GetType .PackageName (print $typeName " " $key) $schema }} ` + "`" + `json:"{{$key}},omitempty"` + "`" + `
{{- end -}}

{{- define "enum"}}
{{- $schema := .RuntimeParams.schema }}
{{- $description := .RuntimeParams.description }}
{{- $name := .RuntimeParams.name }}
{{- $enumType := $.CheckPackage ($.EnumName $name) $.PackageName -}}
{{- if and (empty $schema.Ref) (not (empty $schema.Value.Enum)) }}

// {{$enumType}}
{{- goDoc $description }}
type {{ $enumType }} int8

const (
    Unknown{{ $enumType }} {{ $enumType }} = iota
    {{- range $i, $value := $schema.Value.Enum }}
    {{ $enumType }}{{ pascal (goToken (printf "%v" $value)) }}
    {{- end }}
)

func New{{ $enumType }}(name string) {{ $enumType }} {
    switch name {
    {{- range $schema.Value.Enum  }}
    case "{{ . }}":
        return {{ $enumType }}{{ pascal (goToken (printf "%v" .)) }}
    {{- end }}
    }

    return {{ $enumType }}(0)
}

var  {{ $enumType }}String = map[{{ $enumType }}]string{
    {{- range $schema.Value.Enum }}
        {{ $enumType }}{{ pascal (goToken (printf "%v" .)) }}: "{{ (printf "%v" .) }}",
    {{- end }}
}

func (e {{ $enumType }}) String() string {
    return {{ $enumType }}String[e]
}

func (e *{{ $enumType }}) UnmarshalJSON(input []byte) (err error) {
	var i int8

	err = json.Unmarshal(input, &i)
	if err == nil {
		*e = {{ $enumType }}(i)
		return nil
	}

	var s string

	err = json.Unmarshal(input, &s)
	if err != nil {
		return err
	}

	*e = New{{ $enumType }}(s)

	return nil
}

func (e *{{ $enumType }}) MarshalJSON() ([]byte, error) {
    return json.Marshal(e.String())
}
{{- end -}}
{{- end -}}

{{- define "typeDeclaration"}}
{{ $schema := .RuntimeParams.schema }}
{{- $key := .RuntimeParams.key }}
{{- $label := .RuntimeParams.label }}

{{- if not ($.HasExtension $schema "x-go-type" )}}
{{- $typeName := $.GetType $.PackageName $key $schema }}
// {{ $typeName}}
{{- goDoc $schema.Value.Description }}
//
// OpenAPI {{$label}}: {{ $key }}

    {{- if in $schema.Value.Type "object" "" }}
type {{ pascal $key }} struct {
    {{- range $key, $schema := $.SchemaProperties $schema  false}}
        {{- template "propertyDeclaration" ($.WithParams "key" $key "schema" $schema "typeName" $typeName)}}
    {{- end }}
    {{- range $schema.Value.AllOf }}
        {{- if notEmpty .Ref }}

    // OpenAPI Ref: {{ .Ref }}
    {{ $.GetType $.PackageName "" . }}
        {{- end }}
    {{- end }}
}
    {{- else }}
type {{ pascal $key }} {{ $.GetType $.PackageName (pascal (print $typeName " Item" )) $schema }}
    {{- end }}

{{- /* Nested Types */}}
    {{- range $key, $schema := $.SchemaProperties $schema false }}
        {{- if not (empty $schema.Value.Properties )}}
            {{- if empty $schema.Ref -}}
                {{- template "typeDeclaration" ($.WithParams "key" (pascal (print $typeName " " $key)) "schema" $schema "label" (print  $typeName " inline " $key))}}
            {{- end -}}
        {{- else if eq $schema.Value.Type "array"}}
            {{- if empty $schema.Value.Items.Ref -}}
                {{- if not (empty ($.SchemaProperties $schema.Value.Items false ))}}
                    {{- template "typeDeclaration" ($.WithParams "key" (pascal (print $typeName " " $key)) "schema" $schema.Value.Items "label" (print  $typeName " inline item " $key))}}
                {{- end }}
            {{- end }}
        {{- end }}
    {{- end }}
        {{- /* Nested Arrays */}}
    {{- if eq $schema.Value.Type "array"}}
        {{- if empty $schema.Value.Items.Ref -}}
            {{- if not (empty ($.SchemaProperties $schema.Value.Items false ))}}
                {{- template "typeDeclaration" ($.WithParams "key" (pascal (print $typeName " Item" )) "schema" $schema.Value.Items "label" (print  $typeName " inline item " $key))}}
            {{- end }}
        {{- end }}
    {{- end }}

{{- /*    Regex Validation Patterns */ -}}
    {{- range $key, $schema := $.SchemaProperties $schema false}}
        {{- if notEmpty $schema.Value.Pattern }}
var {{ camel $typeName }}{{ pascal $key }}Pattern = regexp.MustCompile(` + "`" + `{{ $schema.Value.Pattern }}` + "`" + `)
        {{- end}}
    {{- end }}

{{- /*    Enums */}}
    {{- range $key, $schema := $.SchemaEnums $schema }}
        {{- template "enum" ($.WithParams "name" (print $typeName " " $key) "schema" $schema "description" (print $label " : " $key ))}}
    {{- end -}}

{{- $hasValidation := $.HasValidation $schema -}}
{{- if or $hasValidation  $schema.Value.Required }}

func (p *{{ pascal $key }}) UnmarshalJSON(b []byte) error {
    {{- if $schema.Value.Required }}
    var requiredCheck map[string]interface{}

    if err := json.Unmarshal(b, &requiredCheck); err != nil {
        return validation.Error{err.Error(), fmt.Errorf("{{ pascal $key }}.UnmarshalJSON Required: ` + "`" + `%v` + "`" + `: %w", string(b), err)}
    }

    var validationErrors validation.Errors
    {{ range $field := $schema.Value.Required }}
    if _, ok := requiredCheck["{{ $field }}"]; !ok {
        validationErrors.Add("{{ $field }}", "missing required field")
    }
    {{ end }}

    if validationErrors != nil {
        return validationErrors.GetErr()
    }
    {{ end }}
    type  {{ pascal $key }}JSON {{ pascal $key }}
    var parseObject {{ pascal $key }}JSON

    if err := json.Unmarshal(b, &parseObject); err != nil {
        return validation.Error{err.Error(), fmt.Errorf("{{ pascal $key }}.UnmarshalJSON: ` + "`" + `%v` + "`" + `: %w", string(b), err)}
    }

    v := {{ pascal $key }}(parseObject)

{{ if $hasValidation}}
    if err := v.Validate(); err != nil {
        return err
    }
{{ end }}

    p = &v

    return nil
}

    {{ if $hasValidation}}
func (p {{ pascal $key }}) MarshalJSON() ([]byte, error) {
    if err := p.Validate(); err != nil {
        return nil, err
    }

    b, err := json.Marshal(p)
    if err != nil {
        return nil, fmt.Errorf("{{ pascal $key }}.Marshal: ` + "`" + `%+v` + "`" + `: %w", p, err)
    }

    return b, nil
}
    {{ end }}
{{end}}

    {{- if $.HasValidation $schema }}
func (p {{ pascal $key }}) Validate() error {
    var err validation.Errors
        {{- range $key, $schema := $.SchemaProperties $schema true }}
            {{- if in $schema.Value.Type "number" "integer" }}
                {{- $fieldType := $.GetType $.PackageName $key $schema }}
                {{- if isNotNil $schema.Value.Min }}

    if p.{{ pascal $key }} <{{ if $schema.Value.ExclusiveMin }}={{end}} {{ $schema.Value.Min }} {
        _ = err.Add("{{$key}}", "must be >{{ if not $schema.Value.ExclusiveMin }}={{end}} {{ $schema.Value.Min }}")
    }
                {{- end }}
                {{- if isNotNil $schema.Value.Max }}

    if p.{{ pascal $key }} >{{ if $schema.Value.ExclusiveMax }}={{end}} {{ $schema.Value.Max }} {
        _ = err.Add("{{$key}}", "must be <{{ if not $schema.Value.ExclusiveMax }}={{end}} {{ $schema.Value.Max }}")
    }
                {{- end }}
                {{- if isNotNil $schema.Value.MultipleOf }}
                    {{- if eq $schema.Value.Type "integer" }}

    if p.{{ pascal $key }} % {{ $schema.Value.MultipleOf }} != 0 {
        _ = err.Add("{{$key}}", "must be multiple of {{ $schema.Value.MultipleOf }}")
    }
                    {{- else }}
    if math.Mod({{ if not (eq $fieldType "float64") }}float64({{ end }}p.{{ pascal $key }}{{ if not (eq $fieldType "float64") }}){{end}}, {{ $schema.Value.MultipleOf }}) != 0 {
        _ = err.Add("{{$key}}", "must be multiple of {{ $schema.Value.MultipleOf }}")
    }
                    {{- end }}
                {{- end }}
            {{- else if eq $schema.Value.Type "string" }}
                {{- $fieldType := $.GetType $.PackageName $key $schema }}
                {{- if gt $schema.Value.MinLength 0 }}

    if len(p.{{ pascal $key }}) < {{ $schema.Value.MinLength }} {
        _ = err.Add("{{$key}}", "length must be >= {{ $schema.Value.MinLength }}")
    }
                {{- end }}
                {{- if isNotNil $schema.Value.MaxLength }}

    if len(p.{{ pascal $key }}) > {{ $schema.Value.MaxLength }} {
        _ = err.Add("{{$key}}", "length must be <= {{ $schema.Value.MaxLength }}")
    }
                {{- end }}
                {{- if notEmpty $schema.Value.Pattern }}

    if !{{ camel $typeName }}{{ pascal $key }}Pattern.MatchString( p.{{ pascal $key }})  {
        _ = err.Add("{{$key}}", ` + "`" + `must match "{{ $schema.Value.Pattern }}"` + "`" + `)
    }
                {{- end }}
            {{- else if eq $schema.Value.Type "array" }}
                {{- if gt $schema.Value.MinItems 0 }}

    if len(p.{{ pascal $key }}) < {{ $schema.Value.MinItems }} {
        _ = err.Add("{{$key}}", "length must be >= {{ $schema.Value.MinItems }}")
    }
                {{- end }}
                {{- if isNotNil $schema.Value.MaxItems }}

    if len(p.{{ pascal $key }}) > {{ $schema.Value.MaxItems }} {
        _ = err.Add("{{$key}}", "length must be <= {{ $schema.Value.MaxItems }}")
    }
                {{- end }}
            {{- else if notEmpty $schema.Ref }}
                {{- if $.HasValidation $schema }}

    if subErr := p.{{ pascal $key }}.Validate(); subErr != nil {
        _ = err.Add("{{ $key }}", subErr)
    }
                {{- end -}}
            {{- end }}
        {{- end }}

    return err.GetErr()
}
    {{- end -}}
{{- end -}}
{{- end -}}

// Code generated by foji {{ version }}, template: {{ templateFile }}; DO NOT EDIT.

package {{ .PackageName }}

import (
    "regexp"

{{- .CheckAllTypes .PackageName -}}
{{ range .GoImports }}
    "{{ . }}"
{{- end }}

    "github.com/bir/iken/validation"
)

// Component Schemas

{{ range $key, $schema := .ComponentSchemas }}
    {{- template "typeDeclaration" ($.WithParams "key" $key "schema" $schema "label" "Component Schema")}}
{{- end }}

// Component Parameters

{{ range $key, $param := .ComponentParameters }}
        {{- template "paramDeclaration" ($.WithParams "param" $param "name" "" "label" "Component Parameter: ")}}
{{- end }}

{{- define "paramDeclaration"}}
    {{- $param := .RuntimeParams.param }}
    {{- $name := .RuntimeParams.name }}
    {{- $label := .RuntimeParams.label }}
    {{- if empty $param.Ref -}}
        {{- template "enum" ($.WithParams "name" (print $name " " $param.Value.Name) "schema" $param.Value.Schema "description" (print $param.Value.Description "\n" $label $param.Value.Name ))}}
        {{- if eq $param.Value.Schema.Value.Type "array"}}
            {{- template "enum" ($.WithParams "name" (print $name " " $param.Value.Name) "schema" $param.Value.Schema.Value.Items "description" (print $label $param.Value.Name " Item"))}}
        {{- end }}
    {{- end -}}
{{- end }}

// Path Operations

{{/* Inline Request/Reponse Types */ -}}
{{ range $name, $path := .API.Paths }}
    {{- range $verb, $op := $path.Operations }}
        {{- /* Inline Request */ -}}
        {{- $bodySchema := $.GetRequestBodyLocal $op}}
        {{- if $.SchemaIsComplex $bodySchema -}}
            {{- template "typeDeclaration" ($.WithParams "key" (print $op.OperationID "Request") "schema" $bodySchema "label" (print $op.OperationID " Body") )}}
        {{- end }}

        {{- /* Inline Response */ -}}
        {{- $opResponse := $.GetOpHappyResponse $.PackageName $op }}
        {{- if isNotNil $opResponse.MediaType }}
            {{- if  $.SchemaIsComplex $opResponse.MediaType.Schema -}}
                {{- template "typeDeclaration" ($.WithParams "key" (print $op.OperationID " Response") "schema" $opResponse.MediaType.Schema "label" (print $op.OperationID " Response") )}}
            {{- end }}
        {{- end }}

        {{- /* Inline Params */ -}}
        {{- range $param := $.OpParams $path $op }}
            {{- template "paramDeclaration" ($.WithParams "param" $param "name" $op.OperationID "label" (print "Op: " $op.OperationID " Param: "))}}
        {{- end }}
    {{- end }}
{{- end }}
`

// foji/openapi/service.go.tpl
var FojiSlashOpenapiSlashServiceDotGoDotTplBytes = []byte(FojiSlashOpenapiSlashServiceDotGoDotTpl)

const FojiSlashOpenapiSlashServiceDotGoDotTpl = `{{- define "methodSignature"}}
    {{- $path := .RuntimeParams.path -}}
    {{- $op := .RuntimeParams.op -}}
    {{- $body := .GetRequestBody $op -}}
    {{- $package := .RuntimeParams.package -}}
    {{- if not (empty ($.OpSecurity $op)) }} user *{{ $.CheckPackage $.Params.Auth $package -}},{{- end }}
    {{- range $param := $.OpParams $path $op -}}
        {{- $name := (print $op.OperationID " " $param.Value.Name) -}}
        {{ goToken (camel $param.Value.Name) -}}
        {{- if notEmpty $param.Ref -}}
            {{- $name = $param.Value.Name -}}
        {{- end -}}
        {{- if $.ParamIsOptionalType $param }} *{{ end }} {{ $.GetType $package $name $param.Value.Schema }},
    {{- end -}}
    {{- if isNotNil $body}}
        {{- $type := $.GetType $package (print $op.OperationID "Request") $body.Schema }} body {{ $type  -}}
    {{- end -}}
	) (
    {{- $response := $.GetOpHappyResponseType $package .RuntimeParams.op}}
    {{- if notEmpty $response}}{{ $.CheckPackage $response $package}}, {{ end }}error)
{{- end -}}

package {{ .PackageName }}

import (
	"context"

{{- .CheckAllTypes .PackageName ($.Params.GetWithDefault "Auth" "") -}}
{{ range .GoImports }}
	"{{ . }}"
{{- end }}
)

type Error string

func (e Error) Error() string {
	return string(e)
}

const ErrNotImplemented = Error("not implemented")

// New creates a new service instance.
func New() *Service {
	return &Service{}
}

// Service implements all business logic for {{ .PackageName }}.
type Service struct {
}

{{- range $name, $path := .File.API.Paths }}
	{{- range $verb, $op := $path.Operations }}

{{ goDoc (pascal $op.OperationID) }}
{{- goDoc $op.Summary }}
{{- goDoc $op.Description }}
func (s *Service) {{ pascal $op.OperationID}}(ctx context.Context,
	{{- template "methodSignature" ($.WithParams "op" $op "path" $path "package" $.PackageName) }}{
	{{- $response := $.GetOpHappyResponseType $.PackageName $op}}
	{{- if notEmpty $response }}
	return nil, ErrNotImplemented
	{{- else }}
	return ErrNotImplemented
	{{- end }}
}
	{{- end }}
{{- end }}`

// foji/openapi/stub.yaml.tpl
var FojiSlashOpenapiSlashStubDotYamlDotTplBytes = []byte(FojiSlashOpenapiSlashStubDotYamlDotTpl)

const FojiSlashOpenapiSlashStubDotYamlDotTpl = `{{ .NotNeededIf (empty .Params.Name) "params.Name not set" -}}
openapi: "3.0.0"
info:
  title: {{case .Params.Name}}
  version: 0.1.0
paths:
{{- range .Resources }}
  {{- $resource := . }}
  /{{ camel .Name }}:
    get:
      operationId: list{{ pascal .Name }}
      summary: List {{ pascal .Name }}
      tags:
        - {{ case .Name }}
      parameters:
        - $ref: '#/components/parameters/offset'
        - $ref: '#/components/parameters/limit'
      responses:
        '200':
          description: |-
            200 response
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/{{ case (pluralUniqueName .Name) }}'
        default:
          description: unexpected error
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/Error"
{{- if not .Table.ReadOnly }}
    post:
      operationId: create{{ pascal .Name }}
      summary: Create {{ pascal .Name }}
      tags:
        - {{ case .Name }}
      responses:
        '201':
          description: |-
            200 response
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/{{ pascal .Name }}'
{{end -}}
{{if .PK -}}
{{with .PK }}
  /{{ camel $resource.Name }}/{ {{- camel .Name -}} }:
    parameters:
      - name: {{ camel .Name }}
        in: path
        description: {{ camel .Name }} of {{ pascal $resource.Name }}
        required: true
        schema:
          type: {{ .Type }}
{{- with .Format }}
          format: {{ . }}
{{end -}}
{{end }}
    get:
      description: Get {{ pascal .Name }}
      operationId: get{{ pascal .Name }}
      summary: Get {{ pascal .Name }}
      tags:
        - {{ case .Name }}
      responses:
        '200':
          description: successful response
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/{{ pascal .Name }}'
        default:
          description: unexpected error
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Error'
{{- if not .Table.ReadOnly }}
    post:
      description: updates a {{ pascal .Name }}
      operationId: update{{ pascal .Name }}
      summary: Update {{ pascal .Name }}
      tags:
        - {{ case .Name }}
      responses:
        '200':
          description: {{ pascal .Name }} updated
        default:
          description: unexpected error
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Error'
    delete:
      description: deletes a {{ pascal .Name }}
      operationId: delete{{ pascal .Name }}
      summary: Delete {{ pascal .Name }}
      tags:
        - {{ case .Name }}
      responses:
        '204':
          description: {{ pascal .Name }} deleted
        default:
          description: unexpected error
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Error'
{{end -}}
{{end -}}
{{end -}}
components:
  responses:
    BadRequest:
      description: The specified resource was not found
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/Error'
    NotFound:
      description: The specified resource was not found
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/Error'
    Unauthorized:
      description: Unauthorized
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/Error'
  parameters:
    limit:
      name: limit
      in: query
      description: How many items to return for each page
      required: false
      schema:
        type: integer
        format: int32
        default: 100
        maximum: 255
        minimum: 10
    offset:
      name: offset
      in: query
      description: Offset of page to return
      required: false
      schema:
        type: integer
        format: int32
        default: 0
        minimum: 0
  schemas:
{{- range .Resources }}
    {{pascal .Name}}:
      type: object
      properties:
{{- range .Properties }}
        {{ camel .Name }}:
          type: {{ .Type }}
{{- with .Format }}
          format: {{ . }}
{{- end -}}
{{end}}
    {{case (pluralUniqueName .Name) }}:
      type: object
      properties:
        page:
          type: integer
        pageSize:
          type: integer
        totalRecordCount:
          type: integer
        list:
            type: array
            items:
              $ref: '#/components/schemas/{{ pascal .Name }}'
{{- end}}
    Error:
      type: object
      required:
        - code
        - message
      properties:
        code:
          type: integer
          format: int32
        message:
          type: string`

// foji/pgx/db.go.tpl
var FojiSlashPgxSlashDbDotGoDotTplBytes = []byte(FojiSlashPgxSlashDbDotGoDotTpl)

const FojiSlashPgxSlashDbDotGoDotTpl = `// Code generated by foji {{ version }}, template: {{ templateFile }}; DO NOT EDIT.

package pg

import (
	"context"
	"database/sql"
	"errors"

	"github.com/jackc/pgx/v5/pgconn"
	"github.com/jackc/pgx/v5"
)

// DB is the common interface for database operations.
type DB interface {
	Exec(context.Context, string, ...interface{}) (pgconn.CommandTag, error)
	Query(context.Context, string, ...interface{}) (pgx.Rows, error)
	QueryRow(context.Context, string, ...interface{}) pgx.Row
}

func IsErrNoRows(err error) bool {
	return errors.Is(err, pgx.ErrNoRows) || errors.Is(err, sql.ErrNoRows)
}

type Repo struct {
	db DB
}

func New(db DB) Repo {
	return Repo{db: db}
}`

// foji/pgx/model.go.tpl
var FojiSlashPgxSlashModelDotGoDotTplBytes = []byte(FojiSlashPgxSlashModelDotGoDotTpl)

const FojiSlashPgxSlashModelDotGoDotTpl = `// Code generated by foji {{ version }}, template: {{ templateFile }}; DO NOT EDIT.
{{- $table := .Table.Name}}
{{- $goName := case .Table.Name -}}
{{- $colNames := .Table.Columns.ByOrdinal.Names }}
{{- $pkNames := cases .Table.PrimaryKeys.ByOrdinal.Names }}

package {{ $.PackageName }}

import (
	"fmt"

{{- range .Imports }}
	"{{ . }}"
{{- end }}
)

// {{$goName}} represents a record from '{{.Schema.Name}}.{{$table}}'.
type {{$goName}} struct {
{{- range .Table.Columns.ByOrdinal }}
	{{ case .Name }} {{ $.GetType . $.PackageName }}  ` + "`" + `json:"{{ .Name }},omitempty"` + "`" + `
{{- end }}
}

func (r {{$goName}}) String() string {
	return fmt.Sprintf( "{{$goName}}{
		{{- csv ($pkNames.Sprintf "%s:%%v" ) }}}",
		{{- csv ($pkNames.Sprintf "r.%s" ) }})
}

// Field values for every column in {{.Table.Name}}.  These are used for custom where clause queries
var (
{{- range .Table.Columns.ByOrdinal }}
	{{$goName}}{{case .Name}} {{ title (replaceEach ( $.GetType . $.PackageName) "" "." "*" "{" "}" ) }}Field = "{{ .Name }}"
{{- end}}
)

`

// foji/pgx/table.go.tpl
var FojiSlashPgxSlashTableDotGoDotTplBytes = []byte(FojiSlashPgxSlashTableDotGoDotTpl)

const FojiSlashPgxSlashTableDotGoDotTpl = `// Code generated by foji {{ version }}, template: {{ templateFile }}; DO NOT EDIT.
{{- $pkgName := "pg" }}
{{- $table := .Table.Name}}
{{- $schema := .Table.Schema.Name}}
{{- $goName := case $table }}
{{- $hasSoftDeletes := .Table.Columns.Names.Contains "deleted_at"}}
{{- $mutableCols := (.Table.Columns.Filter .Table.PrimaryKeys.Paths).ByOrdinal.Names }}
{{- $mutableFields := (cases $mutableCols).Sprintf "row.%s"}}
{{- $scanFields := (cases .Table.Columns.ByOrdinal.Names).Sprintf "&row.%s"}}
{{- $selectFields := csv .Table.Columns.ByOrdinal.Names}}
{{- $PKs := cases .Table.PrimaryKeys.ByOrdinal.Names }}
{{- $PKFields := csv ($PKs.Sprintf "row.%s")}}
{{- $PKScanFields := csv ($PKs.Sprintf "&row.%s")}}

package {{ $pkgName }}

import (
	"context"
	"fmt"

	"github.com/jackc/pgx/v5"

	"{{.Params.Package}}"
{{- range .Imports }}
	"{{ . }}"
{{- end }}
)

const querySelect{{$goName}} = ` + "`" + `SELECT
	{{ $selectFields }}
FROM {{$schema}}.{{$table}} ` + "`" + `

func scan{{$goName}}(rr pgx.Rows) ([]*{{$.PackageName}}.{{$goName}}, error) {
	var result []*{{$.PackageName}}.{{$goName}}
	for rr.Next() {
		row := {{$.PackageName}}.{{$goName}}{}
		err := rr.Scan({{ csv $scanFields }})
		if err != nil {
			return nil, fmt.Errorf("scan{{$goName}}:%w", err)
		}
		result = append(result, &row)
	}
	return result, nil
}

func scanOne{{$goName}}(rr pgx.Row) (*{{$.PackageName}}.{{$goName}}, error) {
	row := {{$.PackageName}}.{{$goName}}{}
	err := rr.Scan({{ csv $scanFields }})
	if err != nil {
		return nil, fmt.Errorf("{{$goName}}:%w", err)
	}
	return &row, nil
}

// All retrieves all rows from '{{$table}}' as a slice of {{$goName}}.
func (r Repo) All{{$goName}}(ctx context.Context) ([]*{{$.PackageName}}.{{$goName}}, error) {
	query :=  querySelect{{$goName }}
{{- if $hasSoftDeletes -}}
	+ ` + "`" + `WHERE deleted_at is NULL ` + "`" + `
{{- end}}
	q, err := r.db.Query(ctx,query)
	if err != nil {
		return nil, fmt.Errorf("{{$goName}}:%w", err)
	}
	return scan{{$goName}}(q)
}

// Count gets size of '{{$table}}'.
func (r Repo) Count{{$goName}}(ctx context.Context, where {{$.PackageName}}.WhereClause) (int, error) {
	idx := 1
	query := ` + "`" + `SELECT
		count(*) as count
		FROM {{$schema}}.{{$table}}
		WHERE ` + "`" + ` + where.String(&idx)
		
	count := 0
	return count, r.db.QueryRow(ctx, query, where.Values()...).Scan(&count)
}

// Select retrieves rows from '{{$table}}' as a slice of {{$goName}}.
func (r Repo) Select{{$goName}}(ctx context.Context, where {{$.PackageName}}.WhereClause) ([]*{{$.PackageName}}.{{$goName}}, error) {
	idx := 1
	query := querySelect{{$goName}} + " WHERE " + where.String(&idx)
{{- if $hasSoftDeletes -}}
	+ ` + "`" + ` AND deleted_at is NULL ` + "`" + `
{{- end}}

	q, err := r.db.Query(ctx, query, where.Values()...)
	if err != nil {
		return nil, fmt.Errorf("{{$goName}}:%w", err)
	}
	return scan{{$goName}}(q)
}

// SelectOrder retrieves rows from '{{$table}}' as a slice of {{$goName}} in a particular order.
func (r Repo) SelectOrder{{$goName}}(ctx context.Context, where {{$.PackageName}}.WhereClause, orderBy {{$.PackageName}}.OrderByClause) ([]*{{$.PackageName}}.{{$goName}}, error) {
	idx := 1
	query := querySelect{{$goName}} + " WHERE " + where.String(&idx)
{{- if $hasSoftDeletes -}}
	+ ` + "`" + ` AND deleted_at is NULL ` + "`" + `
{{- end}} + " " + orderBy.String()

	q, err := r.db.Query(ctx, query, where.Values()...)
	if err != nil {
		return nil, fmt.Errorf("{{$goName}}:%w", err)
	}
	return scan{{$goName}}(q)
}

// First retrieve one row from '{{$table}}' when sorted by orderBy.
func (r Repo) First{{$goName}}(ctx context.Context, where {{$.PackageName}}.WhereClause, orderBy {{$.PackageName}}.OrderByClause) (*{{$.PackageName}}.{{$goName}}, error) {
	idx := 1
	query := querySelect{{$goName}} + " WHERE " + where.String(&idx)
{{- if $hasSoftDeletes -}}
	+ ` + "`" + ` AND deleted_at is NULL ` + "`" + `
{{- end}} + " " + orderBy.String() + " LIMIT 1"

	q := r.db.QueryRow(ctx, query, where.Values()...)
	return scanOne{{$goName}}(q)
}

{{- /* Takes the number of values to produce and produces a list of postgres
placeholders of the form $1, $2, etc */}}
{{- define "values" -}}
	{{$nums := numbers 1 . -}}
	{{$indices := $nums.Sprintf "$%s" -}}
	{{csv $indices -}}
{{end}}

// Insert inserts the row into the database.
func (r Repo) Insert{{$goName}}(ctx context.Context, row *{{$.PackageName}}.{{$goName}}) error {
const query = ` + "`" + `INSERT INTO {{$schema}}.{{$table}}
{{- if gt (len $mutableCols) 0}}
	({{ csv $mutableCols }})
	VALUES
	({{template "values" (len $mutableCols) }})
{{- else}}
	DEFAULT VALUES
{{- end}}
	RETURNING
		{{csv .Table.PrimaryKeys.Names.Sort }}` + "`" + `
	q := r.db.QueryRow(ctx, query,{{- csv $mutableFields }})
	return q.Scan({{$PKScanFields}})
}
{{if gt (len $mutableCols) 0}}
// Update the Row in the database.
func (r Repo) Update{{$goName}}(ctx context.Context, row *{{$.PackageName}}.{{$goName}}) error {
	query := ` + "`" + `UPDATE {{$schema}}.{{$table}}
	SET
		({{csv $mutableCols }}) =
		({{ template "values" (len $mutableCols) }})
	WHERE
	{{$last := sum (len .Table.PrimaryKeys) (len $mutableCols)}}
	{{- $first := inc (len $mutableCols)}}
	{{- range $x, $name := .Table.PrimaryKeys.Names.Sort -}}
		{{$name}} = ${{sum $first $x}}{{if lt (sum $x $first) $last}} AND {{end}}
	{{- end}}` + "`" + `

	_, err := r.db.Exec(ctx, query, {{csv $mutableFields }}, {{$PKFields}})
	return fmt.Errorf("{{$goName}}:%w", err)
	}
{{end}}
// Set sets a single column on an existing row in the database.
func (r Repo) Set{{$goName}}(ctx context.Context, set {{$.PackageName}}.Where, where {{$.PackageName}}.WhereClause) (int64, error) {
	idx := 2
	query := ` + "`" + `UPDATE {{$schema}}.{{$table}} SET ` + "`" + ` +
		set.Field + " = $1 " +
		` + "`" + `WHERE ` + "`" + ` +
		where.String(&idx)

	res, err := r.db.Exec(ctx, query, append([]interface{}{ set.Value }, where.Values()...)...)
	if err != nil {
		return 0, fmt.Errorf("{{$goName}}:%w", err)
	}
	return res.RowsAffected(), nil
}
{{- if .Table.HasPrimaryKey }}
{{- if $hasSoftDeletes}}
// Delete{{$goName}} soft deletes the row from the database. Returns the number of items soft deleted.
{{else}}
// Delete{{$goName}} deletes the Row from the database. Returns the number of items deleted.
{{end}}
func (r Repo) Delete{{$goName}}( ctx context.Context, {{ $.Parameterize .Table.PrimaryKeys "%s %s" $pkgName }}) (int64, error) {
	{{- if $hasSoftDeletes}}
	const query = ` + "`" + `UPDATE {{$schema}}.{{$table}}
		SET deleted_at = now()
		WHERE
		{{ range $x, $name := .Table.PrimaryKeys.Names.Sort -}}
			{{$name}} = ${{inc $x}}{{if lt $x (sum (len $.Table.PrimaryKeys) -1)}} AND {{end}}
		{{- end}} AND deleted_at is NULL
		` + "`" + `
	{{- else }}
	const query = ` + "`" + `DELETE FROM {{$schema}}.{{$table}} WHERE
		{{ range $x, $name := .Table.PrimaryKeys.Names.Sort -}}
			{{$name}} = ${{inc $x}}{{if lt $x (sum (len $.Table.PrimaryKeys) -1)}} AND {{end}}
		{{- end}}` + "`" + `{{- end}}
	res, err := r.db.Exec(ctx, query,
	{{- csv .Table.PrimaryKeys.Names.Sort.Camel  -}}
	)
	if err != nil {
		return 0, fmt.Errorf("{{$goName}}:%w", err)
	}
	return res.RowsAffected(), nil
}
{{- if $hasSoftDeletes}}
// DeletePermanent{{$goName}} deletes the Row from the database. This bypasses the soft delete mechanism.
// Returns the number of items deleted.
func (r Repo) DeletePermanent{{$goName}}( ctx context.Context, {{ $.Parameterize .Table.PrimaryKeys "%s %s" $pkgName }}) (int64, error) {
	const query = ` + "`" + `DELETE FROM {{$schema}}.{{$table}} WHERE
		{{ range $x, $name := .Table.PrimaryKeys.Names.Sort -}}
			{{$name}} = ${{inc $x}}{{if lt $x (sum (len $.Table.PrimaryKeys) -1)}} AND {{end}}
		{{- end}}` + "`" + `
	res, err := r.db.Exec(ctx, query,
	{{- csv .Table.PrimaryKeys.Names.Sort.Camel  -}}
	)
	if err != nil {
		return 0, fmt.Errorf("{{$goName}}:%w", err)
	}
	return res.RowsAffected(), nil
}
{{end}}
{{end}}
// DeleteWhere{{$goName}} deletes Rows from the database and returns the number of rows deleted.
func (r Repo) DeleteWhere{{$goName}}(ctx context.Context, where {{$.PackageName}}.WhereClause) (int64, error) {
	idx := 1
{{ if $hasSoftDeletes}}
	query := ` + "`" + `UPDATE {{$schema}}.{{$table}}
		SET deleted_at = now()
		WHERE ` + "`" + ` + where.String(&idx) + ` + "`" + ` AND deleted_at is NULL` + "`" + `
{{ else }}
	query := ` + "`" + `DELETE FROM {{$schema}}.{{$table}}
		WHERE ` + "`" + ` + where.String(&idx)
{{ end }}
	res, err := r.db.Exec(ctx, query, where.Values()...)
	if err != nil {
		return 0, fmt.Errorf("{{$goName}}:%w", err)
	}
	return res.RowsAffected(), nil
}
{{ if $hasSoftDeletes}}
// UndeleteWhere{{$goName}} undeletes the Row from the database.
func (r Repo) Undelete{{$goName}}(ctx context.Context, {{ $.Parameterize .Table.PrimaryKeys "%s %s" $pkgName }}) (int64, error) {
	query := ` + "`" + `UPDATE {{$schema}}.{{$table}}
	SET deleted_at = NULL
	WHERE
{{- range $x, $name := .Table.PrimaryKeys.Names.Sort }}
	{{$name}} = ${{inc $x}}{{if lt $x (sum (len $.Table.PrimaryKeys) -1)}} AND {{end}}
{{- end}} AND deleted_at is not NULL` + "`" + `

	res, err := r.db.Exec(ctx, query, {{ csv .Table.PrimaryKeys.Names.Sort.Camel  -}})
	if err != nil {
		return 0, fmt.Errorf("{{$goName}}:%w", err)
	}
	return res.RowsAffected(), nil
}

// DeleteWherePermanent{{$goName}} deletes the Row from the database. This bypasses the soft delete mechanism.
// Returns the number of items deleted.
func (r Repo) DeleteWherePermanent{{$goName}}(ctx context.Context, where {{$.PackageName}}.WhereClause) (int64, error) {
	idx := 1
	query := ` + "`" + `DELETE FROM {{$schema}}.{{$table}}
		WHERE ` + "`" + ` + where.String(&idx)

	res, err := r.db.Exec(ctx, query,  where.Values()...)
	if err != nil {
		return 0, fmt.Errorf("{{$goName}}:%w", err)
	}
	return res.RowsAffected(), nil
}

// UndeleteWhere{{$goName}} undeletes the Row from the database.
func (r Repo) UndeleteWhere{{$goName}}(ctx context.Context, where {{$.PackageName}}.WhereClause) (int64, error) {
	idx := 1
	query := ` + "`" + `UPDATE {{$schema}}.{{$table}}
		SET deleted_at = null
		WHERE ` + "`" + ` + where.String(&idx) + ` + "`" + ` AND deleted_at is NOT NULL` + "`" + `

	res, err := r.db.Exec(ctx, query, where.Values()...)
	if err != nil {
		return 0, fmt.Errorf("{{$goName}}:%w", err)
	}
	return res.RowsAffected(), nil
}

{{ end -}}

{{ range .Table.Indexes -}}
	{{- $FuncName := print $goName "By" ((cases .Columns.Names).Join "") -}}
	{{- if $.Table.PrimaryKeys.Names.ContainsAll .Columns.Names -}}
		{{- $FuncName = print "Get" $goName -}}
	{{- end -}}
// {{$FuncName}} retrieves a row from '{{$.Table.Schema.Name}}.{{$.Table.Name}}'.
//
// Generated from index '{{.Name}}'.
func (r Repo) {{ $FuncName }}(ctx context.Context, {{ $.Parameterize .Columns "%s %s" $pkgName }}) ({{ if not .IsUnique }}[]{{ end }}*{{$.PackageName}}.{{$goName}}, error) {
	query := querySelect{{$goName}} + ` + "`" + ` WHERE {{csv .Columns.Names.Sort }} = {{template "values" (len .Columns)}}
{{- if $hasSoftDeletes }} AND deleted_at is NULL{{ end}}` + "`" + `

{{- if .IsUnique }}
	q := r.db.QueryRow(ctx, query, {{ csv (.Columns.Names.Sort.Camel) }})
{{- else }}
	q, err := r.db.Query(ctx, query, {{ csv (.Columns.Names.Sort.Camel) }})
	if err != nil {
		return nil, fmt.Errorf("{{$goName}}.{{ $FuncName }}:%w", err)
	}
{{- end }}

{{- if .IsUnique }}
	return scanOne{{$goName}}(q)
{{- else }}
	return scan{{$goName}}(q)
{{- end }}
}

{{ end }}`

// foji.yaml
var FojiDotYamlBytes = []byte(FojiDotYaml)

const FojiDotYaml = `formats:
  go:
    case: pascal
    post:
      - [ "goimports", "-w", "$FILE" ]
    maps:
      type:
        "_name": "[]string"
        bool: bool
        boolean: bool
        double: float64
        int2: int16
        int32: int32
        int4: int32
        int8: int64
        integer: int32
        integer,int64: int64
        jsonb: interface{}
        name: string
        number: float32
        number,double: float64
        number,float: float32
        number,int32: int32
        number,int64: int64
        object: interface{}
        oid: int64
        string: string
        string,date-time: time.Time
        string,date: time.Time
        string,ipv4: net.IP
        string,ipv6: net.IP
        string,uri: net/url.URL
        string,uuid: github.com/google/uuid.UUID
        uuid: github.com/google/uuid.UUID
        text: string
        char: string
        bpchar: string
        timestamptz: time.Time
        varchar: string
  openapi:
    case: pascal
    maps:
      type:
        name: string
        text: string
        int2: integer,int32
        int4: integer,int64
        varchar: string
        timestamptz: string,date-time
        jsonb: object
files:
  sql:
    files:
      - "**/*.sql"
    filter:
      - "db/migrations/.*" # dbMate migrations
  embed:
    files:
      - "embed/*"
    filter:
      - ".*\\.go"
  api:
    files:
      - "openapi.yaml"
processes:
  repo:
    processes: [ sqlRepo, dbRepo ]
  embed:
    format: go
    resources: [ embed ]
    params:
      Package: embed
    EmbedAll:
      embed/embeds_gen.go: foji/embed.go.tpl
  dbList:
    format: console
    case: unchanged
    DbAll:
      stdout: foji/dbList.console.tpl
  sqlRepo:
    format: go
    resources: [ sql ]
    params:
      Package: pg
    SQLFile:
      '{{ fileWithExt .File.Source "_gen.go" }}': foji/sqlRepo.go.tpl
  dbRepo:
    format: go
    DbAll:
      '!pg/repo_gen.go': foji/pgx/db.go.tpl
      fields_gen.go: foji/fields.go.tpl
    DbTable:
      'pg/{{lower .Table.Name}}_gen.go': foji/pgx/table.go.tpl
      '{{lower .Table.Name}}_gen.go': foji/pgx/model.go.tpl
    DbEnum:
      '{{lower .Enum.Name}}_gen.go': foji/enum.go.tpl
  openAPIStub:
    format: openapi
    DbAll:
      '!swagger.yaml': foji/openapi/stub.yaml.tpl
  openAPI:
    format: go
    resources: [ api ]
    OpenAPIFile:
      'http_auth_gen.go': foji/openapi/auth.go.tpl
      'models_gen.go': foji/openapi/model.go.tpl
      '!service.go': foji/openapi/service.go.tpl
      'http_handler_gen.go': foji/openapi/handler.go.tpl
      '!cmd/serve/main.go': foji/openapi/main.go.tpl
  openAPIByTag:
    format: go
    resources: [ api ]
    OpenAPIFile:
      '{{lower .}}/models_gen.go': foji/openapi/model.go.tpl
      '{{lower .}}/http/auth_gen.go': foji/openapi/auth.go.tpl
      '{{lower .}}/http/handler_gen.go': foji/openapi/handler.go.tpl
      '!{{lower .}}/service.go': foji/openapi/service.go.tpl
      '!{{lower .}}/cmd/serve/main.go': foji/openapi/main.go.tpl
  openAPIDocs:
    format: go
    resources: [ api ]
    params:
      Package: doc
    EmbedAll:
      doc/embed_gen.go: foji/embed.go.tpl
      '!doc/handler.go': foji/openapi/docs.go.tpl
`

// init.yaml
var InitDotYamlBytes = []byte(InitDotYaml)

const InitDotYaml = `db:
  connection: "host=localhost dbname=my_project sslmode=disable"
  filter:
    - "*.schema_migrations" # dbMate migrations
sql:
  files:
    - "**/*.sql"
  filter:
    - "db/migrations/.*" # dbMate migrations
embed:
  files:
    - "embed/**"
  filter:
    - "*.go"
`
